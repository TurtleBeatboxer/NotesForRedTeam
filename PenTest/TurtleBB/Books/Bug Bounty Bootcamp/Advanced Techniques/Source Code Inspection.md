You'll sometimes come across the source code of an application you're attacking. For example, you might be able to extract JavaScript code from a web application, find scripts stored on servers during the recon process, or obtain Java source code from an Android application. If so, you are in luck! Reviewing code is one of the best ways to find vulnerabilities in applications.

Source code review not only is a faster way of finding vulnerabilities, but also helps you learn how to program safely in the future, because you'll observe the mistakes of others.


#### White-Box vs. Black-Box Testing
You might have heard people in the cybersecurity industry mention blackbox and white-box testing. Black-box testing is testing the software from the outside in. Like a real-life attacker, these testers have little understanding of the application’s internal logic. In contrast, in gray-box testing, the tester has limited knowledge of the application’s internals. In a white-box review, the tester gets full access to the software’s source code and documentation.

### **The Fast Approach: grep Is Your Best Friend**
There are several ways to go about hunting for vulnerabilities in source code, depending on how thorough you want to be. We’ll begin with what “I'll take what I can get” strategy. It works great if you want to maximize the number of bugs found in a short time. These techniques are speedy and often lead to the discovery of some of the most severe vulnerabilities, but they tend to leave out the more subtle bugs.

##### Dangerous Patterns
Using the grep command, look for specific functions, strings, keywords, and coding patterns that are known to be dangerous. For example, the use of the eval() function in PHP can indicate a possible [[RCE|code injection vulnerability]].

When you are just starting out reviewing a piece of source code, focus on the search for dangerous functions used on user-controlled data. Table 22-1 lists a few examples of dangerous functions to look out for. The presence of these functions does not guarantee a vulnerability, but can alert you to possible vulnerabilities.
![[Pasted image 20240318171256.png]]


##### Leaked Secrets and Weak Encryption
Look for leaked secrets and credentials. Sometimes developers make the mistake of hardcoding secrets such as API keys, encryption keys, and database passwords into source code. When that source code is leaked to an attacker, the attacker can use these credentials to access the company’s assets. For example, I’ve found hardcoded API keys in the JavaScript files of web applications.
You can look for these issues by grepping for keywords such as key, secret, password, encrypt, API, login, or token. You can also regex search for hex or base64 strings, depending on the key format of the credentials you're looking for. For instance, GitHub access tokens are lowercase, 40-character hex strings. A search pattern like ``[a-f0-9]{40}`` would find them in the source code. This search pattern matches strings that are 40 characters long and contains only digits and the hex letters a to f.

Entropy scanning can help you find secrets that don’t adhere to a specific format. In computing, entropy is a measurement of how random and unpredictable something is. For instance, a string composed of only one repeated character, like aaaaa, has very low entropy. A longer string with a larger set of characters has higher entropy. Entropy is therefore a good tool to find highly randomized and complex strings, which often indicate a secret. TruffleHog by Dylan Ayrey (https://github.com/trufflesecurity/truffleHog/) is a tool that searches for secrets by using both regex and entropy scanning.

Finally, look for the use of weak cryptography or hashing algorithms. This issue is hard to find during black-box testing but easy to spot when reviewing source code. Look for issues such as weak encryption keys, breakable encryption algorithms, and weak hashing algorithms. Grep the names of weak algorithms like ECB, MD4, and MD5. The application might have functions named after these algorithms, such as ecb(), create md4(), or md5_hash(). It might also have variables with the name of the algorithm, like ecb_key, and so on. The impact of weak hashing algorithms depends on where they are used. If they are used to hash values that are not considered security sensitive, their usage will have less of an impact than if they are used to hash passwords.

##### New Patches and Outdated Dependencies
If you have access to the commit or change history of the source code, you can also focus your attention on the most recent code fixes and security patches. Recent changes haven't stood the test of time and are more likely to contain bugs. Look at the protection mechanisms implemented and see if you can bypass them.

Also search for the program’s dependencies and check whether any of them are outdated. Grep for specific code import functions in the language you are using with keywords like import, require, and dependencies. Then research the versions they’re using to see if any vulnerabilities are associated with them in the [[TurtleBB/Dictionary/CVE]] database (https://cve.mitre.org/). The process of scanning an application for vulnerable dependencies is called software composition analysis (SCA). The OWASP **Dependency-Check tool** (https://owasp.org/www-project-dependency-check/) can help you automate this process. Commercial tools with more capabilities exist too.


##### Developer Comments
You should also look for developer comments and hidden debug functionalities, and accidentally exposed configuration files. These are resources that developers often forget about, and they leave the application in a dangerous state.

Developer comments can point out obvious programming mistakes. For example, some developers like to put comments in their code to remind themselves of incomplete tasks. They might write comments like this, which points out vulnerabilities in the code:

``// todo: Implement CSRF protection on the change password endpoint.

You can find developer comments by searching for the comment characters of each programming language. In Python, it’s #. In Java, JavaScript, and C++, it’s //. You can also search for terms like todo, fix, completed, config, setup, and removed in source code.

##### Debug Functionalities, Configuration Files, and Endpoints
Hidden debug functionalities often lead to privilege escalation, as they’re intended to let the developers themselves bypass protection mechanisms. You can often find them at special endpoints, so search for strings like HTTP, HTTPS, FTP, and dev. For example, you might find a URL like this somewhere in the code that points you to an admin panel:
``http://dev.example.com/admin?debug-18password-password # Access debug panel
Configuration files allow you to gain more information about the target application and might contain credentials. You can look for filepaths to configuration files in source code as well. Configuration files often have the file extensions .conf, .env, .cnf, .cfg, .cf, ini, .sys, or .plist.

Next, look for additional paths, deprecated endpoints, and endpoints in development. These are endpoints that users might not encounter when using the application normally. But if they work and are discovered by an attacker, they can lead to vulnerabilities such as authentication bypass and sensitive information leak, depending on the exposed endpoint. You can search for strings and characters that indicate URLs like HTTP, HTTPS, slashes (/), URL parameter markers (?), file extensions (.php, .himl, .js, json), and so on.

### **The Detailed Approach**
If you have more time, complement the fast techniques with a more extensive source code review to find subtle vulnerabilities. Instead of reading the entire codebase line by line, try these strategies to maximize your efficiency.

##### Important Functions
When reading source code, focus on important functions, such as authentication, password reset, state-changing actions, and sensitive info reads. Things like SQL queries hard coded can be sign of presence of SQL injection.

Which parts of the application are important depend on the priorities of the organization. Also review how important components interact with other parts of the application. This will show you how an attacker's input can affect different parts of the application.

##### User Input
Another approach is to carefully read the code that processes user input. User input, such as HTTP request parameters, HTTP headers, HTTP request paths, database entries, file reads, and file uploads provide the entry points for attackers to exploit the application’s vulnerabilities. This can help find common vulnerabilities such as stored XSS, SQL injections, and XXEs.

Focusing on parts of the code that deal with user input will provide a good starting point for identifying potential dangers. Make sure to also review how the user input gets stored or transferred. Finally, see whether other parts of the application use the previously processed user input. You might find that the same user input interacts differently with various components of the application.

Can you spot the vulnerabilities in the following piece of PHP code?
```
<?php

[...] 

$url path = parse url($ GET['download file'], PHP URL PATH);
$command = ‘wget -o stdout https://example.com' . $url path;
system($command, $output);
echo "<h1> You requested the page:" . $url path . "</h1>";
echo $output;

[...]

?>
```
This page contains a command injection vulnerability and a reflected XSS vulnerability. You can find them by paying attention to where the application uses the user-supplied download_file parameter.


### **In order to summarize**
Code review is an effective way of finding vulnerabilities, so if you can extract source code at any point during your hacking process, dive into the source code and see what you can find. Manual code review can be timeconsuming. Using **static analysis security testing (SAST)** tools is a great way to automate the process. Many open source and commercial SAST tools with different capabilities exist, so if you are interested in code analysis and participating in many source code programs, you might want to look into using a SAST tool that you like.


















