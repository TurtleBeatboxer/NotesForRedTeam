Cross-Site Request Forgery is a technique used client side in order to attack other users of webapp. By suing CSRF attackers can send http requests, which are mimicking victims origin and are making unwanted actions in their name. For example changing password or transsfering money via bank account.

Attackers cannot possibly read responses to his CSRF requests, because responses are sent to victims.

When you login into website for example Twitter, server of this app will send to your browser session cookie via header Set-Cookie in HTTP response. Your browser then saves cookie and later on sends it with every new http request send to Twitter. By doing that server knows that your requests are verified.

Let's say that on Twitter page there is HTML form for making tweet, and button for submitting it. After filling out form and later on clicking submit we will send request. It will contain said cookie so that user that filled form is the one that is actually making tweet.

Now if the request is able to be sent from not only this webapp but literally anywhere else on the internet, the cookie that is used on Twitter still will be sent if the browser still contains.

Let's imagine that attackers host has its own webapp which shows form in HTML same as the one on Twitter. If the request beneath submit button is the same as the one on twitter, attackers host will make the curl to the Tweeter by using cookie from the browser. That way the user will have tweeted something that they didn't. Twitter will accept those curls, because they contain cookie that was directed to user as a way of authentication.

What attacker can achieve via CSRF is very much depended on where the CSRF is found. For example if we wind CSRF on the "discard cart" button it will probably just be obnoxious and annoying for users. But if it is found on something crucial like changing password, attackers can change password of users against their will and fully hijack their accounts. CSRF can be also vital during finding of self inflicted XSS, forcing user to do it.

### **To prevent CSRF**
Best method to combat CSRF errors is to use CSRF tokens. Application can place on their websites those random and unpredictable Strings and websites will sent those when trying to make http request. Those types of tokens should be unique for every session and for as many forms as possible, so that attacker cannot guess value of token and place it inside his webpages Tokens should be characterised by entropy sufficient enough so that attacker cannot reverse-engineer it.

So whenever there is request backend should also request parameter of CSRF token. And if there is none, or if it is not correct, server should decline it. Many frameworks actually contain those by default, so it is only matter of implementing it.

Sometimes it is also advised to aim for using SameSite header with strict value.

Chrome actually automatically uses header SameSite=lax which prevents CSRF attacks on chrome users. In Firefox users have to actually enable it manually, but it is still available to them.

Even though there are some mechanics to avoid easy crsf sometimes they won't work. For example if the website allow to change password with GET HTTP. Other origin websites can still attack users by creating CSRF that are GET request. For example:
https://email.example.com/password_change?new_password=abc123
Because clicking above link will navigate user to highest level in Get request there are gonna still be cookies of user session present and attack will be successful. 

In next scenario websites will be manually setting SameSite atribute of cookie to none. Some websites have functionalities that are requiring external websites to send authentication request between websites. In those cases we can place SameSite inside cookie file with value of None and allow ourselves to send cookies between different origins/sources. And if the user doesn't use browsers that are proof to csrf (ergo Firefox, Internet Explorer, Safari) we can still use CSRF if the target website doesn't implement its own defensive mechanisms.

### **Hunt Down CSRFs**
CSRF's are easy to track and omnipresent. You should start hunting them from looking for functionalities that are changing state of an user. Then test if for any protection or defensive mechanism and still remember that not every browser works the same so you should test it with as many browsers as possible.

So track down requests that are changing state of an user. For example: password change, sending email, deleting email. 

Look for lack of protection. Make burp just be proxy without intercept and look for lack of signs of working protection. No SameSite header.

If there is none protection present try to implement csrf in your own malicious website and look if you could change state of object by interacting with it. 

Sometimes it won't work due to additional invisble protection. For example server can look for referer header and see whether requests comes from accepted host.

### **How to avoid protection**
So you found some kind of protection? It probably sucks. It is done poorly most of the times due to nature of programmers. I was one myself so I know what I am talking about. 

Sometimes you can try:
[[Clickjacking]] - explained somewhere else in vulnerabilities folder. It can be used to avoid control of origin of request.

Trying to change method of Request - sometimes endpoints accept many different methods on the same endpoint but not for every one of them there is protection implemented. If POST has to have CSRF token you can try to do GET and see whether you could not provide it.

Try to provide empty token - self-explanatory, sometimes works due to sheer luck.

Try to not provide token - same as above. 

Look for double CSRF token - sometimes website has two parameters and it check whether they match on receiving. This sucks. You can just change both of them so that their value matches and it doesn't have to be anything related to the way in which its generated. There is one problem. Probably you can't change users cookie. If you find way to change it, it is as easy as it gets.

Delete referer header - self-explanatory, sometimes works due to sheer luck. Done by doing: <meta name="referer" conent="no-referrer">

Make your subdomain contain name of targets host name - self-explanatory, sometimes works due to sheer luck. Maybe system is validating only if the String of hostname is present who knows. Or maybe make it a directory on your website. Example:
target: example.com
our website: example.com.attacker.com / attacker.com/website.com


#### **Escalation**
Can be done for example by injecting self XSS. It can be also be done by changing ways in which data is sent to user so that is sent to attacker. Sometimes you can try to hijack account with CSRF. For example if it is present on webpages that are designed to changing password or changing emails etc.

To get money for CSRF we have to show to owners of bug bounty program real world impact of said problem. We can create external website that has form to be completed with submit button.

Sometimes CSRF can be hidden behind image:
<img src="https://emai.example.com.com/set_password?new_password=this_account_is_mine"> 

If field on the forum is vulnerable due to stored XSS we can use that to make CSRF.

Burp Suite Pro and Zap generate Proof of Concept of CSRF.

