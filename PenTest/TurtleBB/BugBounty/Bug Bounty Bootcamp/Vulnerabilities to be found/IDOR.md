Insecure Direct Object Reference are found in every bug bounty program. They're found when application gives access to the resource based on user request without checking his permissions to do so.

For example: 
Website example.com is social media website where users can talk to other users via chat. When registering you can see that your user ID is provided on website and it is 1234. This webpage allows user to search through their chat history when clicking button. The request is to the following localization: https://example.com/messages?user_id=1234 

If u have above body temperature amount of iQ you can clearly see that you can try to provide other users id to maybe access their messages. So you try doing something like:
https://example.com/messages?user_id=1233

And boom, now you have access to someone else's messages. 

Another Example:
You try to change password and your proxy intercepts this kind of request
```
POST /change_password

{body of post}

user_id=1234&new_password=12345
```
Once again if u have above room temperature amount of iQ you will try to change user_id to someone else's id in order to change their password. 

Sometimes IDORs lets you check some resources like https://example.com/uploads?file=user1234-01.jpg

You could try to access anyone else's files or even try to do path traversal attack and found out /etc/shadow file that contains passwords of users.

https://example.com/uploads?file=/path/to/etc/shadow

### **How to combat IDORs**
**"IDORs"** are present when application is bad on two levels. Firstly it didn't implement any control of access based n the user identity. Secondly it doesn't randomize identification of objects, which means that they're predictable.

In above examples we could see that server never checked for user's identity and we could provide the ID ourselves. It returned information based on our provided info.

So what should application do? First of all it should check whether provided in request id matches with cookie of the user that requested it. If it does it should return resource, if not it should decline request. Secondly, the website should use unique and unpredictable keys or hashes to refer to the resources of individual users.

for example:
https://example.com/messages?user_key=6MT9EalV9F7r9pns0mK1eDAEW
If the attacker cannot find anywhere user_key it would be pretty much impossible for him to access someone else's key.

### **To Find IDORs**
In order to find IDORs we should either inspect source code lookin for methods that take in user_id as a parameter or if we don't have aspect to source code we should create two accounts on same webapp and then check whether switching their ids in requests actually make an impact.

It is advised to pay for services so that we get access to their more advanced functionalities. Not many people who bug bount pay for those, so it's far less populated areas to check.

Then we should look for functionalities that change state of user. Modify data, or add it or even delete it from the server. Collecting user data, changing password/mail, getting files, deleting group.

Then we should intercept requests. Look every one of them throughout and remember that IDORs can be anywhere. In url, in post data, form inputs, filepaths, directories or even headers or cookies.

In order to boost performance of testing log in on two browsers and on both of them log in to different account. Intercept request from one user and from second one. Next change parameters of request so that they match with other account to try change data for different account.

IDORs are really persistent in REST APIs or GraphQL APIs.

### **To make your way through protection against IDORs**
IDORs typically aren't as easily available as on the examples above. (Don't take it for granted, sometimes they're and it's funny)

Sometimes Identificators are just encoded version of numerical id. It iz what it iz so always try to decode everything that you can find.
Sometimes they don't have enough entropy and you can easily predict other users id. In this case you should try to create many accounts so that you can guess what kind of algorithm ids are based on.

Sometimes things can be hidden beneath scary looking alphanumerical encrypted ids. 
/messages?conversation_id=01SUR7GJ43HS93VAR8xXxX
But then you fill find directory and endpoint that can get you this ID. Or maybe try sending the same request with other parameter that you can actually find? In above there was another request that could be made to collect list of users conversation and then use them to collect all messages
GET /messages?user_id=12345

Sometimes you can try to parse the identificator even when application doesn't ask for it. Nowadays almost everyone uses cookies instead of Ids in requests. But sometimes there is alternative way to collect data by providing not authentication token, but pure user ID. It can be leftover from a method that was used by programmers to test funcionalities. 
If it is post throw in some &user_id=, &message_id=. If it is get throw in some 
?user_id=ID_OF_OTHERUSER. Sometimes it works and you can be happy.

Sometimes you can look for blind IDORs. For example changing mail to which you should receive billing data. There will be no immediate response, but if you can provide your ID as parameter you should still check it. Another plus of looking for those is that blind vulnerabilities are very rarely found by automated tools.

You could also try to change method of Request. Applications often implement many methods on same endpoint, but don't implement same mechanics for them. Sometimes if u can't GET resource you can try and DELETE it. Or maybe even if POST doesn't work change it to PUT. 
Also known trick that is using same idea is to change some POST request like this:
POST /get_receipt
receipt_id=2983
into:
GET /get_receipt?receipt_id=2983

Sometimes you can try and change return file type. So Instead of:
GET /get_receipt?receipt_id=2983
we can try:
GET /get_receipt?receipt_id=2983.json

### **Escalation**
It depends on the functionality that it is found in (as always).
IDORs can be **read-based** so they only disclose personal info and its huge on its own or maybe they're  **stored** so they can be used for further escalation.

To look for read-based IDORs one should look for functionalities of reading messages, contact info, or private content

To look for stored IDORs one should look for changing state of user, so recovering account, password change, recovering password, resetting password.

Sometimes stored IDORs can be used with self XSS so that user stores XSS that is sending out their personal info. And again IDOR on admin account can lead to [[TurtleBB/Dictionary/RCE]].

### **Tools for automation**
As always burp suite pro, but actually there are three additional extensions for poor people without burp suite pro (like me). 
Autorize https://github.com/Quitten/Autorize/ it is addon to burp which scans websites in search of problems with escalation and it receives access to accounts with higher level of authorisation. 

Auto Repeater https://github.com/nccgroup/AutoRepeater/ and 
AuthMatrix https://github.com/SecurityInnovation/AuthMatrix they automate process of changing cookie files and headers and paraemeters of our requests. 

Use BAppStore to access these. They should be free.