Funny things about those is that in the book, the chapter started with words: To understand Race Conditions you must first understand concurrency and how it works. I worked as junior/intern programmer for 2 years and never understood it, so here we are.

Race Conditions are one of the most interesting vulnerabilities find in nowadays webapps. They appear due to simple programming errors. Attackers can use race conditions to steal money from internet bank services, e-commerce sites, brokers or even cryptocurrency stock. Let's take a closer look on how they appear.

### **When and How**
Race Conditions occurs when the specific execution sequence of two sections of code is disrupted. To understand how it works I have to first briefly describe concurrency. In computer science concurrency is the ability to run multiple different functionalities of program without having impact on the output data. Properly implemented concurrency is drastically improving performance of an app.

We distinguish two types of concurrency.
**Symmetric multiprocessing** - is when we use several CPUs for simultaneous calculations.

**Multithreading** - is when we use single CPU to process multiple threads which is being done simultaneously. To be exact they're not simultaneous, they exchange computing power among themselves. When one thread is inactive other threads can still use processing power. When one thread is suspended.

When we're trying to plan sequence of thread processing it is called scheduling. Different systems use different algorithms for doing so that are depended on performance priority. Some systems schedule more heavy threads as first to be done and some as last. And some systems even try to complete them simultaneously by giving them computing power in turns.

Because of this whole scheduling there are situations of Race Conditions. 
https://en.wikipedia.org/wiki/Race_condition
Assume that two threads each increment the value of a global integer variable by 1. Ideally, the following sequence of operations would take place:
![[Pasted image 20240313100209.png]]
In the case shown above, the final value is 2, as expected. However, if the two threads run simultaneously without locking or synchronization,the outcome of the operation could be wrong. The alternative sequence of operations below demonstrates this scenario:
![[Pasted image 20240313100308.png]]


To summarize Race Condition is when result of second Thread is depended on the first Thread and they're both sharing same resources without taking into consideration fact that other threads might also be using those resources 
Wordy sentence eh? I can not explain it better, cause I am far less advanced. I mean I understand above pictures, but the sentence is. 

Some backend languages are more prune to Race Condition. You guessed it I'm talking about C++/C

### **When does Race Condition become vulnerability?**
Race condition becomes vulnerability when it has impact on mechanisms of security control. In those cases attacker can make a situation where fragile and dangerous functionality is done before security measures. Because of that they're also called:
**time-of-check vulnerability** or **time-of-use vulnerability**

Let's imagine that two threads from previous example are doing something more crucial like transferring money between bank accounts.
One of them is trying to actually make user have balance on their account and second thread is verifying if the first user had money to transfer it.
If there will be Race Condition present, user might get money from pure air, because transaction will not be concluded due to not enough balance of one user, but the second user is still going to get money from the transfer.

Sometimes it also can be presented when we try to evaluate if user had make this action once. For example voting. One thread tries to verify if user voted (he didn't) then tries to increment amount of votes and then it marks that user had voted. If user tries to vote two times at once if the concurrency is done wrong he will make two votes at once (if the calls are asynchronous).

### **How to prevent this**
As a Java developer I know of at least one way not mentioned in the book. Using **@Transactional** annotation block changing the state of database till the current is finished. It makes it impossible for second call to actually alter table before the first transaction finishes.

**Synchronization** is also a proper way to do so that two threads cannot access one resource at the same time.

**Least Privilege** should be given to application and processes. What I mean is that application and processes shouldn't be allowed to do more than it is necessary. Functionalities that read only, shouldn't be allowed to also write or save things down.

### **How to find them in wild?**
Theoretically every webapp could be target of Race Conditions. 

Almost always those types of vulnerabilities are found when functionalities are using numbers. Number of votes, balance, e-commerce payment, transfers, balance of gift cards. When you see this type of requests you should try to save them as a curl.

Then paste the curl in terminal and paste it second time and put '&' between them so that they're done simultaneously. Remember to always test something that has sense.
If you have 5000$ on accounts, testing the transfer for 7000$ has no sense. As well as testing it for 10$. They won't  check if you are able to abuse concurrency of the system.

Then you should check if you actually made impact. 

### **Escalation**
As always depends on the functionality that the vulnerability is found in. As always try to make maximum impact, so that you gain maximum bounty. It's hard to chain this vulnerability with others, because on it's own race condition can be pretty brutal for the system. 