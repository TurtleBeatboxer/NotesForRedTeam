Server-Side Request Forgery is a vulnerability, which allows attacker to send request on behalf of a server. While exploiting SSRF attacker can forge signatures of requests of vulnerable server, which allows him to gain privileged position in the network. He can avoid [[Firewall]] control and he can gain access to internal services.

### **Mechanisms**
SSRF takes place, when attacker can find a way in which target host can send requests on behalf of a trusted server. Let's imagine a WWW server that is named: public.example.com which works in the network of example.com. This server hosts proxy service that works under public.example.com/proxy, which collects internet service defined in the url parameter and shows it to user. Now let's imagine that the is admin.example.com that hosts admin panel. It is accessible only by private internal network of example.com and isn't hosted outside.
Or is it?
If we use the public.example.com/proxy?url=https://admin.example.com to access admin.example.com we can actually access admin panel externally by using proxy to access internal private network.

SSRF makes servers accept unauthorized requests that would normally be blocked by [[Firewall]], for example downloading administrator panel from computer different than one in the internal network. Often security measures that are present for external networks aren't being implemented in connections inside trusted private network. That's why secure measures that are making admin panel not usable to external users simply don't work against requests made by SSRF.

By forging requests made from trusted servers, attackers can gain access to every tool made available for maintenance and testing. Attacker can try to read confidential files and execute internal API and gain access to internal functionalities.

We differ two types of SSRF. 
**SSRF** - which is just SSRF
**Blind SSRF** - Works just like above, but the difference is that we don't get feedback from server, so we actually can't immediately tell if we had impact. 

Let's imagine that there is another functionality on public.example.com which allows user to send requests via their WWW server. But this endpoint doesn't return user its results. If attackers can send their requests to internal network this endpoint is still SSRF vulnerable, but now its **Blind SSRF** 

### **To combat SSRFs**
SSRF vulnerabilities take place when servers send requests in order to get external resources, but don't prevent using themselves to request internal resources. For example when you share link on twitter it will try to make miniature to help engage people into clicking it. If the twitter allowed its users to make the request for miniature to be made to admin.x.com it would actually be SSRF.

Let's see another example to better understand the problem:
```
POST /download_profile_from_url
HOST: public.example.com

{Post body}
user_id=1234&url=https://www.anotherexample.com/profile.jpg
```
To download profile.jpg the application has to visit the website and download its resource. It is safe behavior. But if the server doesn't differ resources that are external and internal, attacker can also try to request local file that server is containing. Maybe even other files in the private network. For example:
```
POST /download_profile_from_url
HOST: public.example.com

{Post body}
user_id=1234&url=https://localhost/password.txt
```

Main two ways of defending against SSRFs are:
**Blocklist** which is actually list of blocked addresses (so essentially something similar to a [[Blacklist]]). Server blocks every request made addressed to addresses on the list.

**Allowlist** which is actually list of allowed addresses (so essentially something similar to a [[Whitelist]]). Server blocks every request that is not addressed to this list addresses.

Sometimes server allow bypassing their Blocklists and Allowlists by providing request with special headers or secret tokens.

### **How to find SSRF in the wild**
#### 1st Step
Best way to find it is to actually inspect source doe for it, but it is not included in every bug bounty program, so we have to look for functionalities, which are most prune to having SSRFs. So basically hyperlinks, file transfer, processors of document and images, miniatures for hyperlinks and proxy services, endpoints that use user provided urls, webhooks.

Additionally look for: URLs embedded in files processed by the application, hidden APIs that have parameters that are URLs and input data that are inserted as html tags.

Webhooks are non-standard endpoints used as notification system for some event of application. When there is new even like registering new user or error of an application, source site sends HTTP request to an URL of a webhook. Those requests help website collect information about performance of a website and their users and they help with synchronization of data.

Additionally when functionality of one app makes other app do something, webhooks make second process start. For example when we want to send welcome e-mail to every user that starts to follow them on social media, they can use webhook to connect both apps.

Many social medias allow users to configure webhooks and many of those apps are prune to SSRF. In most cases functionality of webhooks is found on the portal of its programmers. Slack for example lets owners of application to configure webhook by using their api. In the even subscription you can put down URL in which Slack will notify you about the event. This input is often prune to SSRFs.

So look for:
Proxies, Webhooks,  file uploads via urls leading to files.

#### 2nd Step
THEN after identifying those endpoints try to shove some internal addresses as parameters. Based on the configuration of network you will have to try few addresses before you can find ones used by the network. Here are some examples:
127.0.0.1 0.0.0.0 192.168.0.1 10.0.0.1 localhost

You can find more on this wikipedia site: https://en.wikipedia.org/wiki/Reserved_IP_addresses

Here is an example of webhook abuse
```
POST /webhook
Host: public.example.com

{post body}
url=https://192.168.0.1
```
or file upload abuse
```
POST /wdownload_profile_from_url
Host: public.example.com

{post body}
user_id=1234&url=https://192.168.0.1
```

#### 3rd step
Look for the results. If the SSRF isn't blind look if the server returns answer that contains any information about internal service. For example try to find if the response contains any [[Banners]].

You can try this by requesting something like this:
```
POST /wdownload_profile_from_url
Host: public.example.com

{post body}
user_id=1234&url=192.168.0.1:22
```
Port 22 is a default port for SSH (refer to [[Common Ports and Protocols]])
If the server will try to access its own SSH you can try to look for something like the following response:
``Error: cannot upload image: SSH-2.0-OpenSSH_7.2p2 Ubuntu-4ubuntu2.4

Easiest way to know if blind SSRF works is to refer the request to a Server, which allows us to have access to its logs. If the server was reached blind SSRF worked. Or you can engage Netcat to make our own computer a server with an open port and monitor incoming traffic. Or you can try to use Collaborator from BURP SUITE PRO which automatically generates unique domain names and sends them as an object to the application and tracks traffic connected to them.
BUT remember. The fact that you can force server to access external resource doesn't mean anything cause it might be blocking internal requests. You know have to try to explore its internal network. Common open ports for trying that are: 22, 80, 443 (once again refer to [[Common Ports and Protocols]], to learn more about those).

To automate guessing if the server is actually prune to ssrf or it will just access external sites you can use:
**SSRFmap (https://github.com/swisskyrepo/SSRFmap)** 
It will automatically try to map out entirety of internal server.

If the port is closed server reacts faster, because it drops the traffic automatically. When traffics is slow and doesn't comeback fast it probably means that firewalls are doing something. Attackers can use those time delays to foretell internal infrastructure of the network. If you can see large time difference between requests to different ports you found useful SSRF.

If you find yourself in this situation:
``Error. Requests to this address are not allowed. Please try again.
SSRF is blocked by allowlist or blocklist. But don't cry, not everything has been lost in the fire. 

### **How to avoid Allowlists**
Those are much harder to bypass than blocklists. But, they're still possible to be bypassed if you can find [[Open Redirect]] vulnerability. If you found [[Open Redirect]] you can request any URL that will redirect Server Request to internal network. So you should angle for something like this:
```
POST /download_profile_from_url
Host: public.example.com

{body of a POST}
user_id=1234&url=https://pics.example.com/123?redirect=127.0.0.1
```

Sometimes Allowlists are done poorly with intern like regexes. So you may try something like this:
```
POST /download_profile_from_url
Host: public.example.com

{body of a POST}
user_id=1234&url=https://pics.example.com/123?redirect@127.0.0.1
```
It will work due to redirection to 127.0.0.1 because subdomains pics.example.com will be seen as a substring of a URL address.

Maybe you could try:
```
POST /download_profile_from_url
Host: public.example.com

{body of a POST}
user_id=1234&url=https://127.0.0.1/pics.example.com
```

If it's regex based everything is possible cause you don't know what the person on the other side of the computer thought of. Just try to guess how does it work.

### **How to avoid Blocklists**
You can try to provide url to your own site:
`` https://public.example.com/proxy?url=https://attacker.com/ssrf
And on your server under the address of https://attacker.com/ssrf you can serve file, which contains following code:
```
<?php header("location: http://127.0.01"); ?>
```
This will redirect the request to document on the internal network effectively making it request its own internal network. Easy as that.

You can also try to use IPv6. Sometimes mechanisms implemented to combat SSRF are working only for IPv4 instead of IPv6 and you can provide IPv6s of local network.

#### **Deceiving server by using DNS system**
Sometimes you can try to Deceive server by using records of DNS, which computers use to translate domain names to IP addresses. Records of DNS names can be configured on the hosting dashboard. You have to make custom mapping of host name to IP addresses so that your domain name points to IPv4 of local network. Next you can try following URL on the request:
``https://public.example.com/proxy?url=https://attacker.com
When the server will try to reach your domain he will try to find it under local network IP that you pointed it to and it will request data from the address.

#### **Changing coding of a URL**
Sometimes programmers make blacklist that completely suck and are prune to bypassing them by encoding blacklisted URL to for example hexadecimal system. So you can try to encode 127.0.0.1 to 0x7f.0x0.0x0.0x1 and try to find out if it works in following url:
``https://public.example.com/proxy?url=https://0x7f.0x0.0x0.0x1


If u can't find an answer to how to bypass security measures try to always change perspective and think of you implementing them. Try to imagine a way in which you would do so and try to exploit it. 


### **Escalation**
As always it depends, but this time it depends on the internal security measures.

You can try to scan private network in search of reachable machines that you can interact with. Try reaching 10.0.0.1, then 10.0.0.2 and then 10.0.0.3 and look for any feedbacks or banners found. You can also look for open ports which responds with banners.

You can try to reach instances metadata. If the server uses for example EC2 of Amazon it has a tool, which allows instances to get intel about themselves by using special queries for an API under address of 169.254.169.254. Instances are virtual servers used to booting applications in vendors cloud services infrastructure. Those APIs are open by default unless administrators block them or turn them off. Informations disclosed by them are confidential and can lead to further escalation.

for example in EC2:
http://169254.169.254/latest/meta-data
http://169254.169.254/latest/meta-data/local-hostname
http://169254.169.254/latest/meta-data/iam/security_credentials/role_name
Can disclose some valuable informations

With Google Cloud it is a bit harder. Google implements some security measures for their API. That's why querying for google API has to have following headers:
``` 
MetaData-Flavor:Google
X-Google-Metadata-Request:True
```
They're protecting server against SSRF, because when exploiting SSRF you almost never can specify special headers. You can easily bypass this by querying not to endpoints of APIv1 but to endpoints of the API v1betal. If you encounter any cloud services read about their APIs documentation online.

### **You can exploit blind SSRFs too**
Because blind SSRFs do not return any responses their exploitation is only connected with mapping network, ports and detecting services. Because you can not extract information from the target server, exploitation is based on inference. Luckily thanks to properly implemented HTTP statuses and response times you can get same results as from normal SSRF, but in bigger time period.

#### **You can scan network and ports by using HTTP statuses**
Let's say we send request to this endpoints:
``https://public.example.com/webhook?url=10.0.0.1
``https://public.example.com/webhook?url=10.0.0.2
And they return HTTP Status 200 and HTTP Status 500 respectively. We can easily guess that 10.0.0.1 is address of a working host, meanwhile 10.0.0.2 isn't. Sometimes sites didn't implement proper statuses. It can be due to laziness or as a security measure. 

#### **You can scan network and ports by using response time**
If server doesn't return any useful information back after making request not everything has been lost. You have to look for differences in response time between different requests. Long response times tend to mean that there is something present there, but its either blocked by firewall or works poorly. Shorter response time means that there is nothing present there most of the time.

### **To escalate SSRF**
Now try to use reconnaissance data that you found. Every listed admin panel and staff you found on sublist3rs should become more available than they were. Sometimes only SSRF lets you take over admin panel. You can also try to make internal API calls. This types of attack requires a lot of intel gained with reconnaissance. Maybe there is an API that you discovered with endpoint that you also discovered in documentation. For example: admin.example.com/delete.user deletes user and can be called only from internal address.

You can also try to get more intel on the application to discover new scopes of attack. Or maybe you found S3 key, so now you can enumerate private S3 buckets and search if you can get access to them with signatures that you found internally.

Sometimes you can also find administrator credentials that can equip you with ability to save files and later on this can lead to [[RCE]]? Or you can try using blind SSRF to send specially prepared and well-known payloads to some services that you guessed that are there? As always depends on the situation