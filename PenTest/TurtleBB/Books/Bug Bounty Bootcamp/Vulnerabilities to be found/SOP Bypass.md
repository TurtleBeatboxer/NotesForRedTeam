Same-Origin Policy is one of the basic security measures in nowadays application. SOP limits a way in which script from other website can interact with script on our site. It is a key component in prevention against many vulnerabilities. But...
Nowadays many sites loosen up their SOP policy in order to get more elastic and dynamic. Those controlled and intentional SOP bypasses can have repercussions, because attackers can sometimes use poor configurations of this techniques to bypass SOP. This can lead to confidential data disclosure and can lead to further exploitation of the site.

### **Mechanisms**
Because of the SOP, a script from page A can access data from page B only if the pages are of the same origin. Same Origin is when two URLs have same protocol, port number and same hostname. Modern web applications often base their authentication on HTTP cookies, and servers take action based on the cookies included automatically by the browser. This means that SOP is important. 

Modern webpages often have to loosen up SOP restrictions because they contain many subdomains and many domains that otherwise couldn't share information if the full restrictions were imposed.

If user had attacker website opened and example.com, attackers website could potentially send requests to example.com using logged user cookies. Because of SOP this isn't possible.
Now let's add the fact that a.example.com communicates with example.com using techniques of bypassing SOP. If you would guess the technique you could potentially request something on users behalf

The simplest way for websites to work around the SOP is to change the origin of a page via JavaScript. Setting the origin of two pages to the same domain using document .domain in the pages’ JavaScript will enable the pages to share resources. For example, you can set the domain of both a.example .com and example.com to example.com so that they can interact:
``document .domain = "example.com"
This has some limitations. You cannot make document domain any domain, but only one that is a super domain of your subdomain. Because of this, this method will work only when you will want to share information through super domains or subdomains that are on the same lvl.

### **Exploiting CORS**
Because of those restriction most of the websites loosen up SOP by using Cross-Origin Resource Sharing (CORS) instead. CORS is a mechanism that is protecting server data.  It allows servers to explicitly specify a list of origins that are allowed to access its resources via the HTTP response header Access-Control-Allow-Origin

In above example if we would apply CORS policy to both domains we would have something of a following HTTP headers:
In request:
``Origin: https://a.example.com
in response we would get lists of allowed Origins:
``Access-Control-Allow-Origin: b.example.com
It can also use wildcards:
``Access-Control-Allow-Origin: *

CORS is perfect way of preventing malicious requests, but only if its configured correctly.
The most common misconfiguration is the permission for the null as an allowed origin. All sites can make a request that has origin set as null. 
Another misconfiguration is to set the Access-Control-Allow-Origin header to the origin of the requesting page without validating the requestor's origin. If the server doesn't validate the origin and returns an Access-Control-Allow -Origin for any origin, the header will completely bypass the SOP, removing all limitations on cross-origin communication.
``Access-Control-Allow-Origin: null
``Access-Control-Allow-Origin: https://attacker.com
Sometimes bad Regex is present and you can try to avoid mechanisms by doing something like that:
``https://www.example.com.attacker.com
If the wild token is used we cannot exploit CORS, because it won't allow usage of any authentications (cookies, jwt etc.), certifications of client etc. So this:
``Access-Control-Allow-Origin: * 
is secure.


### **Exploiting postMessage() method**
Some sites work around SOP by using postMessage(). This method is a web API that uses JavaScript syntax. You can use it to send text-based messages to another window.
``RECIPIENT WINDOW. postMessage(MESSAGE TO SEND, TARGET);
The receiving window would then handle the message by using an event handler that will be triggered when the receiving window receives a message:
``window.addEventListener("message",EVENT HANDLER FUNCTION);

Since using postMessage() requires the sender to obtain a reference to the receiver's window, messages can be sent only between a window and its iframes or pop-ups. That's because only windows that open each other will have a way to reference each other. For example, a window can use window.open to refer to a new window it opened. Alternatively, it can use window.opener to reference the window that spawned the current window. It can use window. frames to reference embedded iframes, and window.parent to reference the parent window of the current iframe.

For example, say we’re trying to pass the following JSON blob located at a.example.com/user_info to b.example.com:
``{}'username': 'vickieli', 'account number': '12345'}

Site a.example.com can open site b.example.com and send message to its windows. Function window.open() opens windows of defined URL address and returns reference to it:
```
ar recipient window - window.open("https://b.example.com", b domain) 
recipient_window.postMessage("('username': 'vickieli', 'account number': '12345'}", "*");
```
At the same time, b.example.com would set up an event listener to process the data it receives:
```
function parse data(event) { 
// Parse the data 
}
window. addEventListener("message", parse data);
```

As we can see postMessage() is a good way to send traffic both ways, but it can be vulnerable. However, when using it, both the sender and the receiver of the message should verify the origin of the other side. Vulnerabilities happen when pages enforce weak origin checks or lack origin checks altogether.
First, the postMessage() method allows the sender to specify the receiver’s origin as a parameter. If the sender page doesn’t specify a target origin and uses a wildcard target origin instead, it becomes possible to leak information to other sites:
```
window_of_receiver.postMessage(KOMUNIKAT_DO_WYSŁANIA, *);
```

In this case attcker can create malicious HTML website which will listen to event coming from the sender. Next it can try to make users initialize postMessage() by using link, devious image and force victim to send data to attackers website.

To avoid this problem programmers should always set TARGET_ORIGIN parameter to the target site’s URL instead of using a wildcard origin
```
recipient_window.postMessage("('username': 'vickieli', 'account number': '12345'}", "https://b.example.com);
```

Take a look at the fact that every window can send requests to b.example.com so every site can initialize change of password on b.example.com. To abuse this behaviour attacker can place or open victims site and gain reference to their window. He can then sent any requests.
To avoid this problem sites should verify origin of message before processing it.
```
function parse data(event) {
	if (event.origin == "https://a.example.com"){
		// If "action" is "password change", change the user's password y 
	}
}
window. addEventListener("message", parse data)
```

### **JSONP**
JSON with Padding it next technique to avoid SOP. It allows sender to send JSON as a Javascript code. Site with other orign can read JSON data by processing Javascript.
To see how this works, let’s continue with our previous example, where we're trying to pass the following JSON blob located at "a.example.com/user_info" to b.example.com:
``{'username": "vickieli", "account number": "12345"}
SOP allows use of ``<script>`` of HTML to load scripts between sites with different origins, because of that b.example.com can easily load data and parse it as a script in the script tag
``<script src="https://a.example.com/user info"></script>

This way, b.example.com would essentially be including the JSON data block in a script tag. But this would cause a syntax error because JSON data is not valid JavaScript:
``<script> "username": "vickieli", "account number": "12345"} </script>

JSONP works around this issue by wrapping the data in a JavaScript function, and sending the data as JavaScript code instead of a JSON file.

The requesting page includes the resource as a script and specifies a callback function, typically in a URL parameter named callback or jsonp. This callback function is a predefined function on the receiving page ready to process the data:
``<script src="https://a.example.com/user_info?callback=parseinfo"></script>

The page at a.example.com will return the data wrapped in the specified callback function:
``parseinfo({"username": "vickieli", "account number": "12345"})

The receiving page would essentially be including this script, which is valid JavaScript code:
```
<script> 
	parseinfo({"username": "vickieli", "account number": "12345"})
</script>
```
The receiving page can then extract the data by running the JavaScript code and processing the parseinfo() function. By sending data as scripts instead of JSON data, JSONP allows resources to be read across origins.

Here's a summary of what happens during a JSONP workflow:
1. The data requestor includes the data’s URL in a script tag, along with the name of a callback function.
2. The data provider returns the JSON data wrapped within the specified callback function.
3. The data requestor receives the function and processes the data by running the returned JavaScript code.
You can usually find out if a site uses JSONP by looking for script tags that include URLs with the terms jsonp or callback.

But JSONP comes with risks. When JSONP is enabled on an endpoint, an attacker can simply embed the same script tag on their site and request the data wrapped in the JSONP payload, like this: 
``<script src="https://a.example.com/user_info?callback=parseinfo"></script>

If a user is browsing the attacker’s site while logged into a.example.com at the same time, the user’s browser will include their credentials in this request and allow attackers to extract confidential data belonging to the victim.

This is why JSONP is suitable for transmitting only public data. While JSONP can be hardened by using CSRF tokens or maintaining an allowlist of referer headers for JSONP requests, these protections can often be bypassed. 
Also if one of the pages is taken over by a hacker it can make second page run all JavaScript provided by a hacker.

Now that CORS is a reliable option for cross-origin communication, sites no longer use JSONP as often.


### **Bypassing SOP with XSS**
Every XSS is a SOP bypass, because you already can run arbitrary JavaScript code on the victims browser.

### **How to find SOP bypasses**
First you have to determine if the application relaxes SOP policies.
Look for signs of techniques of relaxing SOP policies. For example CORS uses HTTP header: 
Access-Control-Allow-Origin. If you found message event listener in your browser you have found postMessage() function. In chrome you find event listeners by clicking right mouse button and selecting Inspect and next selecting Event Listeners. And if u find something like this:
```
<script src="https://a.example.com/user_info?callback=parseinfo"></script>
<script src="https://a.example.com/user_info?jsonp=parseinfo"></script>
```
You probably found JSONP.

##### CORS
If the site is using CORS, check whether the Access-Control-Allow-Origin response header is set to null. So essentially try sending something like:
``Origin: null
If not you can also try sending request with Origin value that is nonsensical. 
``Origin: attacker.com
At last you should try and check whether CORS isn't just using bad regex to verify the origin:
``Origin: example.com.com.attacker.com
There are no more ways.

##### postMessage()
If the website uses postMessage check if you can send and receive messages as an untrusted site. Create HTML with iframe that contains target website that receives messages which change state. If the target can't be placed in iframe you can try to open it as new window
```
var recipient window = window.open("https://TARGET URL", target domain) 
recipient window.postMessage("RANDOM MESSAGE", "*");
```
You can also create an HTML page that listens for events coming from the target page, and trigger the postMessage from the target site. See if you can receive sensitive data from the target page.
```
var sender window - window.open("https://TARGET URL", target domain)

function parse data(event) { 
// Run some code if we receive data from the target
}
window.addEventListener("message", parse data);
```


##### JSONP
Finally, if the site is using JSONP, see if you can embed a script tag on your site and request the sensitive data wrapped in the JSONP payload:
``<script>src="https://TARGET_URL?callback-parseinfo"></script>

When the target site does not rely on cookies for authentication, these SOP bypass misconfigurations might not be exploitable. For instance, when the site uses custom headers or secret request parameters to authenticate requests, you might need to find a way to forge those to exfiltrate sensitive data.


### **Escalation**
They're mainly disclosing confidential data or can make you forge other users action. Due to that they have high impact even without any escalation. Escalation can be achieved mainly by using disclosed information to find new surface of attack or pivoting attack with new info.
Sometimes SOP bypass is found in functionalities that don't disclose any information and then this finding might be worthless if it can't be chained with something else.